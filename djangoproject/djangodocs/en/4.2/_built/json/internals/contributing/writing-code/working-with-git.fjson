{"parents": [{"link": "../../../", "title": "Django internals"}, {"link": "../../", "title": "Contributing to Django"}, {"link": "../", "title": "Writing code"}], "prev": {"link": "../submitting-patches/", "title": "Submitting patches"}, "next": {"link": "../javascript/", "title": "JavaScript"}, "title": "Working with Git and GitHub", "meta": {}, "body": "<div class=\"section\" id=\"s-working-with-git-and-github\">\n<span id=\"working-with-git-and-github\"></span><h1>Working with Git and GitHub<a class=\"headerlink\" href=\"#working-with-git-and-github\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>This section explains how the community can contribute code to Django via pull\nrequests. If you\u2019re interested in how <a class=\"reference internal\" href=\"../../../organization/#mergers-team\"><span class=\"std std-ref\">mergers</span></a> handle\nthem, see <a class=\"reference internal\" href=\"../../committing-code/\"><span class=\"doc\">Committing code</span></a>.</p>\n<p>Below, we are going to show how to create a GitHub pull request containing the\nchanges for Trac ticket #xxxxx. By creating a fully-ready pull request, you\nwill make the reviewer\u2019s job easier, meaning that your work is more likely to\nbe merged into Django.</p>\n<p>You could also upload a traditional patch to Trac, but it\u2019s less practical for\nreviews.</p>\n<div class=\"section\" id=\"s-installing-git\">\n<span id=\"installing-git\"></span><h2>Installing Git<a class=\"headerlink\" href=\"#installing-git\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Django uses <a class=\"reference external\" href=\"https://git-scm.com/\">Git</a> for its source control. You can <a class=\"reference external\" href=\"https://git-scm.com/download\">download</a> Git, but it\u2019s often easier to install with\nyour operating system\u2019s package manager.</p>\n<p>Django\u2019s <a class=\"reference external\" href=\"https://github.com/django/django/\">Git repository</a> is hosted on <a class=\"reference external\" href=\"https://github.com/\">GitHub</a>, and it is recommended\nthat you also work using GitHub.</p>\n<p>After installing Git, the first thing you should do is set up your name and\nemail:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>$ git config --global user.name <span class=\"s2\">&quot;Your Real Name&quot;</span>\n$ git config --global user.email <span class=\"s2\">&quot;you@email.com&quot;</span>\n</pre></div>\n</div>\n<p>Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">user.name</span></code> should be your real name, not your GitHub nick. GitHub\nshould know the email you use in the <code class=\"docutils literal notranslate\"><span class=\"pre\">user.email</span></code> field, as this will be\nused to associate your commits with your GitHub account.</p>\n</div>\n<div class=\"section\" id=\"s-setting-up-local-repository\">\n<span id=\"setting-up-local-repository\"></span><h2>Setting up local repository<a class=\"headerlink\" href=\"#setting-up-local-repository\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When you have created your GitHub account, with the nick \u201cGitHub_nick\u201d, and\n<a class=\"reference external\" href=\"https://github.com/django/django/fork\">forked Django\u2019s repository</a>,\ncreate a local copy of your fork:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git clone https://github.com/GitHub_nick/django.git\n</pre></div>\n</div>\n<p>This will create a new directory \u201cdjango\u201d, containing a clone of your GitHub\nrepository. The rest of the git commands on this page need to be run within the\ncloned directory, so switch to it now:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">cd</span> django\n</pre></div>\n</div>\n<p>Your GitHub repository will be called \u201corigin\u201d in Git.</p>\n<p>You should also set up <code class=\"docutils literal notranslate\"><span class=\"pre\">django/django</span></code> as an \u201cupstream\u201d remote (that is, tell\ngit that the reference Django repository was the source of your fork of it):</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git remote add upstream https://github.com/django/django.git\ngit fetch upstream\n</pre></div>\n</div>\n<p>You can add other remotes similarly, for example:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git remote add akaariai https://github.com/akaariai/django.git\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-working-on-a-ticket\">\n<span id=\"working-on-a-ticket\"></span><h2>Working on a ticket<a class=\"headerlink\" href=\"#working-on-a-ticket\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When working on a ticket, create a new branch for the work, and base that work\non <code class=\"docutils literal notranslate\"><span class=\"pre\">upstream/main</span></code>:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git checkout -b ticket_xxxxx upstream/main\n</pre></div>\n</div>\n<p>The -b flag creates a new branch for you locally. Don\u2019t hesitate to create new\nbranches even for the smallest things - that\u2019s what they are there for.</p>\n<p>If instead you were working for a fix on the 1.4 branch, you would do:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git checkout -b ticket_xxxxx_1_4 upstream/stable/1.4.x\n</pre></div>\n</div>\n<p>Assume the work is carried on the ticket_xxxxx branch. Make some changes and\ncommit them:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git commit\n</pre></div>\n</div>\n<p>When writing the commit message, follow the <a class=\"reference internal\" href=\"../../committing-code/#committing-guidelines\"><span class=\"std std-ref\">commit message\nguidelines</span></a> to ease the work of the merger. If you\u2019re\nuncomfortable with English, try at least to describe precisely what the commit\ndoes.</p>\n<p>If you need to do additional work on your branch, commit as often as\nnecessary:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git commit -m <span class=\"s1\">&#39;Added two more tests for edge cases&#39;</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"s-publishing-work\">\n<span id=\"publishing-work\"></span><h3>Publishing work<a class=\"headerlink\" href=\"#publishing-work\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>You can publish your work on GitHub by running:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git push origin ticket_xxxxx\n</pre></div>\n</div>\n<p>When you go to your GitHub page, you will notice a new branch has been created.</p>\n<p>If you are working on a Trac ticket, you should mention in the ticket that\nyour work is available from branch ticket_xxxxx of your GitHub repo. Include a\nlink to your branch.</p>\n<p>Note that the above branch is called a \u201ctopic branch\u201d in Git parlance. You are\nfree to rewrite the history of this branch, by using <code class=\"docutils literal notranslate\"><span class=\"pre\">git</span> <span class=\"pre\">rebase</span></code> for\nexample. Other people shouldn\u2019t base their work on such a branch, because\ntheir clone would become corrupt when you edit commits.</p>\n<p>There are also \u201cpublic branches\u201d. These are branches other people are supposed\nto fork, so the history of these branches should never change. Good examples\nof public branches are the <code class=\"docutils literal notranslate\"><span class=\"pre\">main</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">stable/A.B.x</span></code> branches in the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">django/django</span></code> repository.</p>\n<p>When you think your work is ready to be pulled into Django, you should create\na pull request at GitHub. A good pull request means:</p>\n<ul class=\"simple\">\n<li>commits with one logical change in each, following the\n<a class=\"reference internal\" href=\"../coding-style/\"><span class=\"doc\">coding style</span></a>,</li>\n<li>well-formed messages for each commit: a summary line and then paragraphs\nwrapped at 72 characters thereafter \u2013 see the <a class=\"reference internal\" href=\"../../committing-code/#committing-guidelines\"><span class=\"std std-ref\">committing guidelines</span></a> for more details,</li>\n<li>documentation and tests, if needed \u2013 actually tests are always needed,\nexcept for documentation changes.</li>\n</ul>\n<p>The test suite must pass and the documentation must build without warnings.</p>\n<p>Once you have created your pull request, you should add a comment in the\nrelated Trac ticket explaining what you\u2019ve done. In particular, you should note\nthe environment in which you ran the tests, for instance: \u201call tests pass\nunder SQLite and MySQL\u201d.</p>\n<p>Pull requests at GitHub have only two states: open and closed. The merger who\nwill deal with your pull request has only two options: merge it or close it.\nFor this reason, it isn\u2019t useful to make a pull request until the code is ready\nfor merging \u2013 or sufficiently close that a merger will finish it themselves.</p>\n</div>\n<div class=\"section\" id=\"s-rebasing-branches\">\n<span id=\"rebasing-branches\"></span><h3>Rebasing branches<a class=\"headerlink\" href=\"#rebasing-branches\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>In the example above, you created two commits, the \u201cFixed ticket_xxxxx\u201d commit\nand \u201cAdded two more tests\u201d commit.</p>\n<p>We do not want to have the entire history of your working process in your\nrepository. Your commit \u201cAdded two more tests\u201d would be unhelpful noise.\nInstead, we would rather only have one commit containing all your work.</p>\n<p>To rework the history of your branch you can squash the commits into one by\nusing interactive rebase:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git rebase -i HEAD~2\n</pre></div>\n</div>\n<p>The HEAD~2 above is shorthand for two latest commits. The above command\nwill open an editor showing the two commits, prefixed with the word \u201cpick\u201d.</p>\n<p>Change \u201cpick\u201d on the second line to \u201csquash\u201d instead. This will keep the\nfirst commit, and squash the second commit into the first one. Save and quit\nthe editor. A second editor window should open, so you can reword the\ncommit message for the commit now that it includes both your steps.</p>\n<p>You can also use the \u201cedit\u201d option in rebase. This way you can change a single\ncommit, for example to fix a typo in a docstring:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git rebase -i HEAD~3\n<span class=\"c1\"># Choose edit, pick, pick for the commits</span>\n<span class=\"c1\"># Now you are able to rework the commit (use git add normally to add changes)</span>\n<span class=\"c1\"># When finished, commit work with &quot;--amend&quot; and continue</span>\ngit commit --amend\n<span class=\"c1\"># Reword the commit message if needed</span>\ngit rebase --continue\n<span class=\"c1\"># The second and third commits should be applied.</span>\n</pre></div>\n</div>\n<p>If your topic branch is already published at GitHub, for example if you\u2019re\nmaking minor changes to take into account a review, you will need to force-push\nthe changes:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git push -f origin ticket_xxxxx\n</pre></div>\n</div>\n<p>Note that this will rewrite history of ticket_xxxxx - if you check the commit\nhashes before and after the operation at GitHub you will notice that the commit\nhashes do not match anymore. This is acceptable, as the branch is a topic\nbranch, and nobody should be basing their work on it.</p>\n</div>\n<div class=\"section\" id=\"s-after-upstream-has-changed\">\n<span id=\"after-upstream-has-changed\"></span><h3>After upstream has changed<a class=\"headerlink\" href=\"#after-upstream-has-changed\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>When upstream (<code class=\"docutils literal notranslate\"><span class=\"pre\">django/django</span></code>) has changed, you should rebase your work. To\ndo this, use:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git fetch upstream\ngit rebase upstream/main\n</pre></div>\n</div>\n<p>The work is automatically rebased using the branch you forked on, in the\nexample case using <code class=\"docutils literal notranslate\"><span class=\"pre\">upstream/main</span></code>.</p>\n<p>The rebase command removes all your local commits temporarily, applies the\nupstream commits, and then applies your local commits again on the work.</p>\n<p>If there are merge conflicts, you will need to resolve them and then use <code class=\"docutils literal notranslate\"><span class=\"pre\">git</span>\n<span class=\"pre\">rebase</span> <span class=\"pre\">--continue</span></code>. At any point you can use <code class=\"docutils literal notranslate\"><span class=\"pre\">git</span> <span class=\"pre\">rebase</span> <span class=\"pre\">--abort</span></code> to return\nto the original state.</p>\n<p>Note that you want to <em>rebase</em> on upstream, not <em>merge</em> the upstream.</p>\n<p>The reason for this is that by rebasing, your commits will always be <em>on\ntop of</em> the upstream\u2019s work, not <em>mixed in with</em> the changes in the upstream.\nThis way your branch will contain only commits related to its topic, which\nmakes squashing easier.</p>\n</div>\n<div class=\"section\" id=\"s-after-review\">\n<span id=\"after-review\"></span><h3>After review<a class=\"headerlink\" href=\"#after-review\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>It is unusual to get any non-trivial amount of code into core without changes\nrequested by reviewers. In this case, it is often a good idea to add the\nchanges as one incremental commit to your work. This allows the reviewer to\neasily check what changes you have done.</p>\n<p>In this case, do the changes required by the reviewer. Commit as often as\nnecessary. Before publishing the changes, rebase your work. If you added two\ncommits, you would run:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git rebase -i HEAD~2\n</pre></div>\n</div>\n<p>Squash the second commit into the first. Write a commit message along the lines\nof:</p>\n<div class=\"highlight-text notranslate\"><div class=\"highlight\"><pre><span></span>Made changes asked in review by &lt;reviewer&gt;\n\n- Fixed whitespace errors in foobar\n- Reworded the docstring of bar()\n</pre></div>\n</div>\n<p>Finally, push your work back to your GitHub repository. Since you didn\u2019t touch\nthe public commits during the rebase, you should not need to force-push:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git push origin ticket_xxxxx\n</pre></div>\n</div>\n<p>Your pull request should now contain the new commit too.</p>\n<p>Note that the merger is likely to squash the review commit into the previous\ncommit when committing the code.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-working-on-a-patch\">\n<span id=\"working-on-a-patch\"></span><h2>Working on a patch<a class=\"headerlink\" href=\"#working-on-a-patch\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>One of the ways that developers can contribute to Django is by reviewing\npatches. Those patches will typically exist as pull requests on GitHub and\ncan be easily integrated into your local repository:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>git checkout -b pull_xxxxx upstream/main\ncurl -L https://github.com/django/django/pull/xxxxx.patch <span class=\"p\">|</span> git am\n</pre></div>\n</div>\n<p>This will create a new branch and then apply the changes from the pull request\nto it. At this point you can run the tests or do anything else you need to\ndo to investigate the quality of the patch.</p>\n<p>For more detail on working with pull requests see the\n<a class=\"reference internal\" href=\"../../committing-code/#handling-pull-requests\"><span class=\"std std-ref\">guidelines for mergers</span></a>.</p>\n</div>\n<div class=\"section\" id=\"s-summary\">\n<span id=\"summary\"></span><h2>Summary<a class=\"headerlink\" href=\"#summary\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<ul class=\"simple\">\n<li>Work on GitHub if you can.</li>\n<li>Announce your work on the Trac ticket by linking to your GitHub branch.</li>\n<li>When you have something ready, make a pull request.</li>\n<li>Make your pull requests as good as you can.</li>\n<li>When doing fixes to your work, use <code class=\"docutils literal notranslate\"><span class=\"pre\">git</span> <span class=\"pre\">rebase</span> <span class=\"pre\">-i</span></code> to squash the commits.</li>\n<li>When upstream has changed, do <code class=\"docutils literal notranslate\"><span class=\"pre\">git</span> <span class=\"pre\">fetch</span> <span class=\"pre\">upstream;</span> <span class=\"pre\">git</span> <span class=\"pre\">rebase</span></code>.</li>\n</ul>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["internals/contributing/writing-code/javascript", "JavaScript", "N", "next"], ["internals/contributing/writing-code/submitting-patches", "Submitting patches", "P", "previous"]], "sourcename": "internals/contributing/writing-code/working-with-git.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Working with Git and GitHub</a><ul>\n<li><a class=\"reference internal\" href=\"#installing-git\">Installing Git</a></li>\n<li><a class=\"reference internal\" href=\"#setting-up-local-repository\">Setting up local repository</a></li>\n<li><a class=\"reference internal\" href=\"#working-on-a-ticket\">Working on a ticket</a><ul>\n<li><a class=\"reference internal\" href=\"#publishing-work\">Publishing work</a></li>\n<li><a class=\"reference internal\" href=\"#rebasing-branches\">Rebasing branches</a></li>\n<li><a class=\"reference internal\" href=\"#after-upstream-has-changed\">After upstream has changed</a></li>\n<li><a class=\"reference internal\" href=\"#after-review\">After review</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#working-on-a-patch\">Working on a patch</a></li>\n<li><a class=\"reference internal\" href=\"#summary\">Summary</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "internals/contributing/writing-code/working-with-git", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}