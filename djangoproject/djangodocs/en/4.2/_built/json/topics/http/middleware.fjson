{"parents": [{"link": "../../", "title": "Using Django"}, {"link": "../", "title": "Handling HTTP requests"}], "prev": {"link": "../generic-views/", "title": "Generic views"}, "next": {"link": "../sessions/", "title": "How to use sessions"}, "title": "Middleware", "meta": {}, "body": "<div class=\"section\" id=\"s-middleware\">\n<span id=\"middleware\"></span><h1>Middleware<a class=\"headerlink\" href=\"#middleware\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Middleware is a framework of hooks into Django\u2019s request/response processing.\nIt\u2019s a light, low-level \u201cplugin\u201d system for globally altering Django\u2019s input\nor output.</p>\n<p>Each middleware component is responsible for doing some specific function. For\nexample, Django includes a middleware component,\n<a class=\"reference internal\" href=\"../../../ref/middleware/#django.contrib.auth.middleware.AuthenticationMiddleware\" title=\"django.contrib.auth.middleware.AuthenticationMiddleware\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AuthenticationMiddleware</span></code></a>, that\nassociates users with requests using sessions.</p>\n<p>This document explains how middleware works, how you activate middleware, and\nhow to write your own middleware. Django ships with some built-in middleware\nyou can use right out of the box. They\u2019re documented in the <a class=\"reference internal\" href=\"../../../ref/middleware/\"><span class=\"doc\">built-in\nmiddleware reference</span></a>.</p>\n<div class=\"section\" id=\"s-writing-your-own-middleware\">\n<span id=\"writing-your-own-middleware\"></span><h2>Writing your own middleware<a class=\"headerlink\" href=\"#writing-your-own-middleware\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>A middleware factory is a callable that takes a <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> callable and\nreturns a middleware. A middleware is a callable that takes a request and\nreturns a response, just like a view.</p>\n<p>A middleware can be written as a function that looks like this:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">simple_middleware</span><span class=\"p\">(</span><span class=\"n\">get_response</span><span class=\"p\">):</span>\n    <span class=\"c1\"># One-time configuration and initialization.</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">middleware</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Code to be executed for each request before</span>\n        <span class=\"c1\"># the view (and later middleware) are called.</span>\n\n        <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">get_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Code to be executed for each request/response after</span>\n        <span class=\"c1\"># the view is called.</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">response</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">middleware</span>\n</pre></div>\n</div>\n<p>Or it can be written as a class whose instances are callable, like this:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">SimpleMiddleware</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">get_response</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_response</span> <span class=\"o\">=</span> <span class=\"n\">get_response</span>\n        <span class=\"c1\"># One-time configuration and initialization.</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Code to be executed for each request before</span>\n        <span class=\"c1\"># the view (and later middleware) are called.</span>\n\n        <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Code to be executed for each request/response after</span>\n        <span class=\"c1\"># the view is called.</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">response</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> callable provided by Django might be the actual view (if\nthis is the last listed middleware) or it might be the next middleware in the\nchain. The current middleware doesn\u2019t need to know or care what exactly it is,\njust that it represents whatever comes next.</p>\n<p>The above is a slight simplification \u2013 the <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> callable for the\nlast middleware in the chain won\u2019t be the actual view but rather a wrapper\nmethod from the handler which takes care of applying <a class=\"reference internal\" href=\"#view-middleware\"><span class=\"std std-ref\">view middleware</span></a>, calling the view with appropriate URL arguments, and\napplying <a class=\"reference internal\" href=\"#template-response-middleware\"><span class=\"std std-ref\">template-response</span></a> and\n<a class=\"reference internal\" href=\"#exception-middleware\"><span class=\"std std-ref\">exception</span></a> middleware.</p>\n<p>Middleware can either support only synchronous Python (the default), only\nasynchronous Python, or both. See <a class=\"reference internal\" href=\"#async-middleware\"><span class=\"std std-ref\">Asynchronous support</span></a> for details of how to\nadvertise what you support, and know what kind of request you are getting.</p>\n<p>Middleware can live anywhere on your Python path.</p>\n<div class=\"section\" id=\"s-init-get-response\">\n<span id=\"init-get-response\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">__init__(get_response)</span></code><a class=\"headerlink\" href=\"#init-get-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Middleware factories must accept a <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> argument. You can also\ninitialize some global state for the middleware. Keep in mind a couple of\ncaveats:</p>\n<ul class=\"simple\">\n<li>Django initializes your middleware with only the <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> argument,\nso you can\u2019t define <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__()</span></code> as requiring any other arguments.</li>\n<li>Unlike the <code class=\"docutils literal notranslate\"><span class=\"pre\">__call__()</span></code> method which is called once per request,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">__init__()</span></code> is called only <em>once</em>, when the web server starts.</li>\n</ul>\n</div>\n<div class=\"section\" id=\"s-marking-middleware-as-unused\">\n<span id=\"marking-middleware-as-unused\"></span><h3>Marking middleware as unused<a class=\"headerlink\" href=\"#marking-middleware-as-unused\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>It\u2019s sometimes useful to determine at startup time whether a piece of\nmiddleware should be used. In these cases, your middleware\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__()</span></code>\nmethod may raise <a class=\"reference internal\" href=\"../../../ref/exceptions/#django.core.exceptions.MiddlewareNotUsed\" title=\"django.core.exceptions.MiddlewareNotUsed\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">MiddlewareNotUsed</span></code></a>. Django will\nthen remove that middleware from the middleware process and log a debug message\nto the <a class=\"reference internal\" href=\"../../../ref/logging/#django-request-logger\"><span class=\"std std-ref\">django.request</span></a> logger when <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-DEBUG\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEBUG</span></code></a> is <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-activating-middleware\">\n<span id=\"activating-middleware\"></span><h2>Activating middleware<a class=\"headerlink\" href=\"#activating-middleware\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>To activate a middleware component, add it to the <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a> list in\nyour Django settings.</p>\n<p>In <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>, each middleware component is represented by a string:\nthe full Python path to the middleware factory\u2019s class or function name. For\nexample, here\u2019s the default value created by <a class=\"reference internal\" href=\"../../../ref/django-admin/#django-admin-startproject\"><code class=\"xref std std-djadmin docutils literal notranslate\"><span class=\"pre\">django-admin</span>\n<span class=\"pre\">startproject</span></code></a>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">MIDDLEWARE</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"s2\">&quot;django.middleware.security.SecurityMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.contrib.sessions.middleware.SessionMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.middleware.common.CommonMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.middleware.csrf.CsrfViewMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.contrib.auth.middleware.AuthenticationMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.contrib.messages.middleware.MessageMiddleware&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;django.middleware.clickjacking.XFrameOptionsMiddleware&quot;</span><span class=\"p\">,</span>\n<span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>A Django installation doesn\u2019t require any middleware \u2014 <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>\ncan be empty, if you\u2019d like \u2014 but it\u2019s strongly suggested that you at least use\n<a class=\"reference internal\" href=\"../../../ref/middleware/#django.middleware.common.CommonMiddleware\" title=\"django.middleware.common.CommonMiddleware\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CommonMiddleware</span></code></a>.</p>\n<p>The order in <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a> matters because a middleware can depend on\nother middleware. For instance,\n<a class=\"reference internal\" href=\"../../../ref/middleware/#django.contrib.auth.middleware.AuthenticationMiddleware\" title=\"django.contrib.auth.middleware.AuthenticationMiddleware\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AuthenticationMiddleware</span></code></a> stores the\nauthenticated user in the session; therefore, it must run after\n<a class=\"reference internal\" href=\"../../../ref/middleware/#django.contrib.sessions.middleware.SessionMiddleware\" title=\"django.contrib.sessions.middleware.SessionMiddleware\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SessionMiddleware</span></code></a>. See\n<a class=\"reference internal\" href=\"../../../ref/middleware/#middleware-ordering\"><span class=\"std std-ref\">Middleware ordering</span></a> for some common hints about ordering of Django\nmiddleware classes.</p>\n</div>\n<div class=\"section\" id=\"s-middleware-order-and-layering\">\n<span id=\"middleware-order-and-layering\"></span><h2>Middleware order and layering<a class=\"headerlink\" href=\"#middleware-order-and-layering\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>During the request phase, before calling the view, Django applies middleware in\nthe order it\u2019s defined in <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>, top-down.</p>\n<p>You can think of it like an onion: each middleware class is a \u201clayer\u201d that\nwraps the view, which is in the core of the onion. If the request passes\nthrough all the layers of the onion (each one calls <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> to pass\nthe request in to the next layer), all the way to the view at the core, the\nresponse will then pass through every layer (in reverse order) on the way back\nout.</p>\n<p>If one of the layers decides to short-circuit and return a response without\never calling its <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code>, none of the layers of the onion inside that\nlayer (including the view) will see the request or the response. The response\nwill only return through the same layers that the request passed in through.</p>\n</div>\n<div class=\"section\" id=\"s-other-middleware-hooks\">\n<span id=\"other-middleware-hooks\"></span><h2>Other middleware hooks<a class=\"headerlink\" href=\"#other-middleware-hooks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Besides the basic request/response middleware pattern described earlier, you\ncan add three other special methods to class-based middleware:</p>\n<div class=\"section\" id=\"s-process-view\">\n<span id=\"s-view-middleware\"></span><span id=\"process-view\"></span><span id=\"view-middleware\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">process_view()</span></code><a class=\"headerlink\" href=\"#process-view\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"process_view\">\n<code class=\"sig-name descname\"><span class=\"pre\">process_view</span></code>(<em><span class=\"n\"><span class=\"pre\">request</span></span></em>, <em><span class=\"n\"><span class=\"pre\">view_func</span></span></em>, <em><span class=\"n\"><span class=\"pre\">view_args</span></span></em>, <em><span class=\"n\"><span class=\"pre\">view_kwargs</span></span></em>)<a class=\"headerlink\" href=\"#process_view\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">request</span></code> is an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpRequest\" title=\"django.http.HttpRequest\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code></a> object. <code class=\"docutils literal notranslate\"><span class=\"pre\">view_func</span></code> is\nthe Python function that Django is about to use. (It\u2019s the actual function\nobject, not the name of the function as a string.) <code class=\"docutils literal notranslate\"><span class=\"pre\">view_args</span></code> is a list of\npositional arguments that will be passed to the view, and <code class=\"docutils literal notranslate\"><span class=\"pre\">view_kwargs</span></code> is a\ndictionary of keyword arguments that will be passed to the view. Neither\n<code class=\"docutils literal notranslate\"><span class=\"pre\">view_args</span></code> nor <code class=\"docutils literal notranslate\"><span class=\"pre\">view_kwargs</span></code> include the first view argument\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">request</span></code>).</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">process_view()</span></code> is called just before Django calls the view.</p>\n<p>It should return either <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> or an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a>\nobject. If it returns <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>, Django will continue processing this request,\nexecuting any other <code class=\"docutils literal notranslate\"><span class=\"pre\">process_view()</span></code> middleware and, then, the appropriate\nview. If it returns an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a> object, Django won\u2019t\nbother calling the appropriate view; it\u2019ll apply response middleware to that\n<a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a> and return the result.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p>Accessing <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpRequest.POST\" title=\"django.http.HttpRequest.POST\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">request.POST</span></code></a> inside\nmiddleware before the view runs or in <code class=\"docutils literal notranslate\"><span class=\"pre\">process_view()</span></code> will prevent any\nview running after the middleware from being able to <a class=\"reference internal\" href=\"../file-uploads/#modifying-upload-handlers-on-the-fly\"><span class=\"std std-ref\">modify the\nupload handlers for the request</span></a>,\nand should normally be avoided.</p>\n<p class=\"last\">The <a class=\"reference internal\" href=\"../../../ref/middleware/#django.middleware.csrf.CsrfViewMiddleware\" title=\"django.middleware.csrf.CsrfViewMiddleware\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CsrfViewMiddleware</span></code></a> class can be\nconsidered an exception, as it provides the\n<a class=\"reference internal\" href=\"../../../ref/csrf/#django.views.decorators.csrf.csrf_exempt\" title=\"django.views.decorators.csrf.csrf_exempt\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">csrf_exempt()</span></code></a> and\n<a class=\"reference internal\" href=\"../../../ref/csrf/#django.views.decorators.csrf.csrf_protect\" title=\"django.views.decorators.csrf.csrf_protect\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">csrf_protect()</span></code></a> decorators which allow\nviews to explicitly control at what point the CSRF validation should occur.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-process-exception\">\n<span id=\"s-exception-middleware\"></span><span id=\"process-exception\"></span><span id=\"exception-middleware\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception()</span></code><a class=\"headerlink\" href=\"#process-exception\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"process_exception\">\n<code class=\"sig-name descname\"><span class=\"pre\">process_exception</span></code>(<em><span class=\"n\"><span class=\"pre\">request</span></span></em>, <em><span class=\"n\"><span class=\"pre\">exception</span></span></em>)<a class=\"headerlink\" href=\"#process_exception\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">request</span></code> is an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpRequest\" title=\"django.http.HttpRequest\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code></a> object. <code class=\"docutils literal notranslate\"><span class=\"pre\">exception</span></code> is an\n<code class=\"docutils literal notranslate\"><span class=\"pre\">Exception</span></code> object raised by the view function.</p>\n<p>Django calls <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception()</span></code> when a view raises an exception.\n<code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception()</span></code> should return either <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> or an\n<a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a> object. If it returns an\n<a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a> object, the template response and response\nmiddleware will be applied and the resulting response returned to the\nbrowser. Otherwise, <a class=\"reference internal\" href=\"../../../ref/views/#error-views\"><span class=\"std std-ref\">default exception handling</span></a> kicks in.</p>\n<p>Again, middleware are run in reverse order during the response phase, which\nincludes <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception</span></code>. If an exception middleware returns a response,\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception</span></code> methods of the middleware classes above that\nmiddleware won\u2019t be called at all.</p>\n</div>\n<div class=\"section\" id=\"s-process-template-response\">\n<span id=\"s-template-response-middleware\"></span><span id=\"process-template-response\"></span><span id=\"template-response-middleware\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">process_template_response()</span></code><a class=\"headerlink\" href=\"#process-template-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"process_template_response\">\n<code class=\"sig-name descname\"><span class=\"pre\">process_template_response</span></code>(<em><span class=\"n\"><span class=\"pre\">request</span></span></em>, <em><span class=\"n\"><span class=\"pre\">response</span></span></em>)<a class=\"headerlink\" href=\"#process_template_response\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">request</span></code> is an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpRequest\" title=\"django.http.HttpRequest\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code></a> object. <code class=\"docutils literal notranslate\"><span class=\"pre\">response</span></code> is\nthe <a class=\"reference internal\" href=\"../../../ref/template-response/#django.template.response.TemplateResponse\" title=\"django.template.response.TemplateResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code></a> object (or equivalent)\nreturned by a Django view or by a middleware.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">process_template_response()</span></code> is called just after the view has finished\nexecuting, if the response instance has a <code class=\"docutils literal notranslate\"><span class=\"pre\">render()</span></code> method, indicating that\nit is a <a class=\"reference internal\" href=\"../../../ref/template-response/#django.template.response.TemplateResponse\" title=\"django.template.response.TemplateResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code></a> or equivalent.</p>\n<p>It must return a response object that implements a <code class=\"docutils literal notranslate\"><span class=\"pre\">render</span></code> method. It could\nalter the given <code class=\"docutils literal notranslate\"><span class=\"pre\">response</span></code> by changing <code class=\"docutils literal notranslate\"><span class=\"pre\">response.template_name</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">response.context_data</span></code>, or it could create and return a brand-new\n<a class=\"reference internal\" href=\"../../../ref/template-response/#django.template.response.TemplateResponse\" title=\"django.template.response.TemplateResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code></a> or equivalent.</p>\n<p>You don\u2019t need to explicitly render responses \u2013 responses will be\nautomatically rendered once all template response middleware has been\ncalled.</p>\n<p>Middleware are run in reverse order during the response phase, which\nincludes <code class=\"docutils literal notranslate\"><span class=\"pre\">process_template_response()</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-dealing-with-streaming-responses\">\n<span id=\"dealing-with-streaming-responses\"></span><h2>Dealing with streaming responses<a class=\"headerlink\" href=\"#dealing-with-streaming-responses\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Unlike <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a>,\n<a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.StreamingHttpResponse\" title=\"django.http.StreamingHttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StreamingHttpResponse</span></code></a> does not have a <code class=\"docutils literal notranslate\"><span class=\"pre\">content</span></code>\nattribute. As a result, middleware can no longer assume that all responses\nwill have a <code class=\"docutils literal notranslate\"><span class=\"pre\">content</span></code> attribute. If they need access to the content, they\nmust test for streaming responses and adjust their behavior accordingly:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">if</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">streaming</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">streaming_content</span> <span class=\"o\">=</span> <span class=\"n\">wrap_streaming_content</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">streaming_content</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">alter_content</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">content</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">streaming_content</span></code> should be assumed to be too large to hold in memory.\nResponse middleware may wrap it in a new generator, but must not consume\nit. Wrapping is typically implemented as follows:</p>\n<div class=\"last highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">wrap_streaming_content</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">chunk</span> <span class=\"ow\">in</span> <span class=\"n\">content</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">alter_content</span><span class=\"p\">(</span><span class=\"n\">chunk</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<p><a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.StreamingHttpResponse\" title=\"django.http.StreamingHttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">StreamingHttpResponse</span></code></a> allows both synchronous and\nasynchronous iterators. The wrapping function must match. Check\n<a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.StreamingHttpResponse.is_async\" title=\"django.http.StreamingHttpResponse.is_async\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">StreamingHttpResponse.is_async</span></code></a> if your middleware needs to\nsupport both types of iterator.</p>\n<div class=\"versionchanged\">\n<span class=\"title\">Changed in Django 4.2:</span> <p>Support for streaming responses with asynchronous iterators was added.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-exception-handling\">\n<span id=\"exception-handling\"></span><h2>Exception handling<a class=\"headerlink\" href=\"#exception-handling\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Django automatically converts exceptions raised by the view or by middleware\ninto an appropriate HTTP response with an error status code. <a class=\"reference internal\" href=\"../../../ref/views/#error-views\"><span class=\"std std-ref\">Certain\nexceptions</span></a> are converted to 4xx status codes, while an unknown\nexception is converted to a 500 status code.</p>\n<p>This conversion takes place before and after each middleware (you can think of\nit as the thin film in between each layer of the onion), so that every\nmiddleware can always rely on getting some kind of HTTP response back from\ncalling its <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> callable. Middleware don\u2019t need to worry about\nwrapping their call to <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> in a <code class=\"docutils literal notranslate\"><span class=\"pre\">try/except</span></code> and handling an\nexception that might have been raised by a later middleware or the view. Even\nif the very next middleware in the chain raises an\n<a class=\"reference internal\" href=\"../views/#django.http.Http404\" title=\"django.http.Http404\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Http404</span></code></a> exception, for example, your middleware won\u2019t see\nthat exception; instead it will get an <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse\" title=\"django.http.HttpResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">HttpResponse</span></code></a>\nobject with a <a class=\"reference internal\" href=\"../../../ref/request-response/#django.http.HttpResponse.status_code\" title=\"django.http.HttpResponse.status_code\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">status_code</span></code></a> of 404.</p>\n<p>You can set <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-DEBUG_PROPAGATE_EXCEPTIONS\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEBUG_PROPAGATE_EXCEPTIONS</span></code></a> to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> to skip this\nconversion and propagate exceptions upward.</p>\n</div>\n<div class=\"section\" id=\"s-asynchronous-support\">\n<span id=\"s-async-middleware\"></span><span id=\"asynchronous-support\"></span><span id=\"async-middleware\"></span><h2>Asynchronous support<a class=\"headerlink\" href=\"#asynchronous-support\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Middleware can support any combination of synchronous and asynchronous\nrequests. Django will adapt requests to fit the middleware\u2019s requirements if it\ncannot support both, but at a performance penalty.</p>\n<p>By default, Django assumes that your middleware is capable of handling only\nsynchronous requests. To change these assumptions, set the following attributes\non your middleware factory function or class:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">sync_capable</span></code> is a boolean indicating if the middleware can handle\nsynchronous requests. Defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">async_capable</span></code> is a boolean indicating if the middleware can handle\nasynchronous requests. Defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>.</li>\n</ul>\n<p>If your middleware has both <code class=\"docutils literal notranslate\"><span class=\"pre\">sync_capable</span> <span class=\"pre\">=</span> <span class=\"pre\">True</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">async_capable</span> <span class=\"pre\">=</span> <span class=\"pre\">True</span></code>, then Django will pass it the request without\nconverting it. In this case, you can work out if your middleware will receive\nasync requests by checking if the <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> object you are passed is a\ncoroutine function, using <code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref.sync.iscoroutinefunction</span></code>.</p>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">django.utils.decorators</span></code> module contains\n<a class=\"reference internal\" href=\"../../../ref/utils/#django.utils.decorators.sync_only_middleware\" title=\"django.utils.decorators.sync_only_middleware\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_only_middleware()</span></code></a>,\n<a class=\"reference internal\" href=\"../../../ref/utils/#django.utils.decorators.async_only_middleware\" title=\"django.utils.decorators.async_only_middleware\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_only_middleware()</span></code></a>, and\n<a class=\"reference internal\" href=\"../../../ref/utils/#django.utils.decorators.sync_and_async_middleware\" title=\"django.utils.decorators.sync_and_async_middleware\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_and_async_middleware()</span></code></a> decorators that\nallow you to apply these flags to middleware factory functions.</p>\n<p>The returned callable must match the sync or async nature of the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code> method. If you have an asynchronous <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code>, you must\nreturn a coroutine function (<code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code>).</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">process_view</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">process_template_response</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception</span></code>\nmethods, if they are provided, should also be adapted to match the sync/async\nmode. However, Django will individually adapt them as required if you do not,\nat an additional performance penalty.</p>\n<p>Here\u2019s an example of how to create a middleware function that supports both:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">iscoroutinefunction</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.utils.decorators</span> <span class=\"kn\">import</span> <span class=\"n\">sync_and_async_middleware</span>\n\n\n<span class=\"nd\">@sync_and_async_middleware</span>\n<span class=\"k\">def</span> <span class=\"nf\">simple_middleware</span><span class=\"p\">(</span><span class=\"n\">get_response</span><span class=\"p\">):</span>\n    <span class=\"c1\"># One-time configuration and initialization goes here.</span>\n    <span class=\"k\">if</span> <span class=\"n\">iscoroutinefunction</span><span class=\"p\">(</span><span class=\"n\">get_response</span><span class=\"p\">):</span>\n\n        <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">middleware</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Do something here!</span>\n            <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">get_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">response</span>\n\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">middleware</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Do something here!</span>\n            <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">get_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">response</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">middleware</span>\n</pre></div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p>If you declare a hybrid middleware that supports both synchronous and\nasynchronous calls, the kind of call you get may not match the underlying\nview. Django will optimize the middleware call stack to have as few\nsync/async transitions as possible.</p>\n<p class=\"last\">Thus, even if you are wrapping an async view, you may be called in sync\nmode if there is other, synchronous middleware between you and the view.</p>\n</div>\n<p>When using an asynchronous class-based middleware, you must ensure that\ninstances are correctly marked as coroutine functions:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">iscoroutinefunction</span><span class=\"p\">,</span> <span class=\"n\">markcoroutinefunction</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">AsyncMiddleware</span><span class=\"p\">:</span>\n    <span class=\"n\">async_capable</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">sync_capable</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">get_response</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_response</span> <span class=\"o\">=</span> <span class=\"n\">get_response</span>\n        <span class=\"k\">if</span> <span class=\"n\">iscoroutinefunction</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_response</span><span class=\"p\">):</span>\n            <span class=\"n\">markcoroutinefunction</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n        <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Some logic ...</span>\n        <span class=\"k\">return</span> <span class=\"n\">response</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-upgrading-pre-django-1-10-style-middleware\">\n<span id=\"s-upgrading-middleware\"></span><span id=\"upgrading-pre-django-1-10-style-middleware\"></span><span id=\"upgrading-middleware\"></span><h2>Upgrading pre-Django 1.10-style middleware<a class=\"headerlink\" href=\"#upgrading-pre-django-1-10-style-middleware\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<dl class=\"py class\">\n<dt class=\"sig sig-object py\" id=\"django.utils.deprecation.MiddlewareMixin\">\n<em class=\"property\"><span class=\"pre\">class</span><span class=\"w\"> </span></em><code class=\"sig-prename descclassname\"><span class=\"pre\">django.utils.deprecation.</span></code><code class=\"sig-name descname\"><span class=\"pre\">MiddlewareMixin</span></code><a class=\"headerlink\" href=\"#django.utils.deprecation.MiddlewareMixin\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>Django provides <code class=\"docutils literal notranslate\"><span class=\"pre\">django.utils.deprecation.MiddlewareMixin</span></code> to ease creating\nmiddleware classes that are compatible with both <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a> and the\nold <code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>, and support synchronous and asynchronous requests.\nAll middleware classes included with Django are compatible with both settings.</p>\n<p>The mixin provides an <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__()</span></code> method that requires a <code class=\"docutils literal notranslate\"><span class=\"pre\">get_response</span></code>\nargument and stores it in <code class=\"docutils literal notranslate\"><span class=\"pre\">self.get_response</span></code>.</p>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">__call__()</span></code> method:</p>\n<ol class=\"arabic simple\">\n<li>Calls <code class=\"docutils literal notranslate\"><span class=\"pre\">self.process_request(request)</span></code> (if defined).</li>\n<li>Calls <code class=\"docutils literal notranslate\"><span class=\"pre\">self.get_response(request)</span></code> to get the response from later\nmiddleware and the view.</li>\n<li>Calls <code class=\"docutils literal notranslate\"><span class=\"pre\">self.process_response(request,</span> <span class=\"pre\">response)</span></code> (if defined).</li>\n<li>Returns the response.</li>\n</ol>\n<p>If used with <code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>, the <code class=\"docutils literal notranslate\"><span class=\"pre\">__call__()</span></code> method will\nnever be used; Django calls <code class=\"docutils literal notranslate\"><span class=\"pre\">process_request()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">process_response()</span></code>\ndirectly.</p>\n<p>In most cases, inheriting from this mixin will be sufficient to make an\nold-style middleware compatible with the new system with sufficient\nbackwards-compatibility. The new short-circuiting semantics will be harmless or\neven beneficial to the existing middleware. In a few cases, a middleware class\nmay need some changes to adjust to the new semantics.</p>\n<p>These are the behavioral differences between using <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>:</p>\n<ol class=\"arabic simple\">\n<li>Under <code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>, every middleware will always have its\n<code class=\"docutils literal notranslate\"><span class=\"pre\">process_response</span></code> method called, even if an earlier middleware\nshort-circuited by returning a response from its <code class=\"docutils literal notranslate\"><span class=\"pre\">process_request</span></code>\nmethod. Under <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>, middleware behaves more like an onion:\nthe layers that a response goes through on the way out are the same layers\nthat saw the request on the way in. If a middleware short-circuits, only\nthat middleware and the ones before it in <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a> will see the\nresponse.</li>\n<li>Under <code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception</span></code> is applied to\nexceptions raised from a middleware <code class=\"docutils literal notranslate\"><span class=\"pre\">process_request</span></code> method. Under\n<a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>, <code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception</span></code> applies only to exceptions\nraised from the view (or from the <code class=\"docutils literal notranslate\"><span class=\"pre\">render</span></code> method of a\n<a class=\"reference internal\" href=\"../../../ref/template-response/#django.template.response.TemplateResponse\" title=\"django.template.response.TemplateResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code></a>). Exceptions raised from\na middleware are converted to the appropriate HTTP response and then passed\nto the next middleware.</li>\n<li>Under <code class=\"docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE_CLASSES</span></code>, if a <code class=\"docutils literal notranslate\"><span class=\"pre\">process_response</span></code> method raises\nan exception, the <code class=\"docutils literal notranslate\"><span class=\"pre\">process_response</span></code> methods of all earlier middleware are\nskipped and a <code class=\"docutils literal notranslate\"><span class=\"pre\">500</span> <span class=\"pre\">Internal</span> <span class=\"pre\">Server</span> <span class=\"pre\">Error</span></code> HTTP response is always\nreturned (even if the exception raised was e.g. an\n<a class=\"reference internal\" href=\"../views/#django.http.Http404\" title=\"django.http.Http404\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Http404</span></code></a>). Under <a class=\"reference internal\" href=\"../../../ref/settings/#std-setting-MIDDLEWARE\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">MIDDLEWARE</span></code></a>, an exception\nraised from a middleware will immediately be converted to the appropriate\nHTTP response, and then the next middleware in line will see that\nresponse. Middleware are never skipped due to a middleware raising an\nexception.</li>\n</ol>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["topics/http/sessions", "How to use sessions", "N", "next"], ["topics/http/generic-views", "Generic views", "P", "previous"]], "sourcename": "topics/http/middleware.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Middleware</a><ul>\n<li><a class=\"reference internal\" href=\"#writing-your-own-middleware\">Writing your own middleware</a><ul>\n<li><a class=\"reference internal\" href=\"#init-get-response\"><code class=\"docutils literal notranslate\"><span class=\"pre\">__init__(get_response)</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#marking-middleware-as-unused\">Marking middleware as unused</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#activating-middleware\">Activating middleware</a></li>\n<li><a class=\"reference internal\" href=\"#middleware-order-and-layering\">Middleware order and layering</a></li>\n<li><a class=\"reference internal\" href=\"#other-middleware-hooks\">Other middleware hooks</a><ul>\n<li><a class=\"reference internal\" href=\"#process-view\"><code class=\"docutils literal notranslate\"><span class=\"pre\">process_view()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#process-exception\"><code class=\"docutils literal notranslate\"><span class=\"pre\">process_exception()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#process-template-response\"><code class=\"docutils literal notranslate\"><span class=\"pre\">process_template_response()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#dealing-with-streaming-responses\">Dealing with streaming responses</a></li>\n<li><a class=\"reference internal\" href=\"#exception-handling\">Exception handling</a></li>\n<li><a class=\"reference internal\" href=\"#asynchronous-support\">Asynchronous support</a></li>\n<li><a class=\"reference internal\" href=\"#upgrading-pre-django-1-10-style-middleware\">Upgrading pre-Django 1.10-style middleware</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "topics/http/middleware", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}