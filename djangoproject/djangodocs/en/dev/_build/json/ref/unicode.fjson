{"parents": [{"link": "../", "title": "API Reference"}], "prev": {"link": "../template-response/", "title": "<code class=\"docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">SimpleTemplateResponse</span></code>"}, "next": {"link": "../urlresolvers/", "title": "<code class=\"docutils literal notranslate\"><span class=\"pre\">django.urls</span></code> utility functions"}, "title": "Unicode data", "meta": {}, "body": "<div class=\"section\" id=\"s-unicode-data\">\n<span id=\"unicode-data\"></span><h1>Unicode data<a class=\"headerlink\" href=\"#unicode-data\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Django supports Unicode data everywhere.</p>\n<p>This document tells you what you need to know if you\u2019re writing applications\nthat use data or templates that are encoded in something other than ASCII.</p>\n<div class=\"section\" id=\"s-creating-the-database\">\n<span id=\"creating-the-database\"></span><h2>Creating the database<a class=\"headerlink\" href=\"#creating-the-database\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Make sure your database is configured to be able to store arbitrary string\ndata. Normally, this means giving it an encoding of UTF-8 or UTF-16. If you use\na more restrictive encoding \u2013 for example, latin1 (iso8859-1) \u2013 you won\u2019t be\nable to store certain characters in the database, and information will be lost.</p>\n<ul class=\"simple\">\n<li>MySQL users, refer to the <a class=\"reference external\" href=\"https://dev.mysql.com/doc/refman/en/charset-database.html\">MySQL manual</a> for details on how to set or alter\nthe database character set encoding.</li>\n<li>PostgreSQL users, refer to the <a class=\"reference external\" href=\"https://www.postgresql.org/docs/current/multibyte.html#id-1.6.11.5.6\">PostgreSQL manual</a> for details on creating\ndatabases with the correct encoding.</li>\n<li>Oracle users, refer to the <a class=\"reference external\" href=\"https://docs.oracle.com/en/database/oracle/oracle-database/21/nlspg/index.html\">Oracle manual</a> for details on how to set\n(<a class=\"reference external\" href=\"https://docs.oracle.com/en/database/oracle/oracle-database/21/nlspg/choosing-character-set.html\">section 2</a>) or alter (<a class=\"reference external\" href=\"https://docs.oracle.com/en/database/oracle/oracle-database/21/nlspg/character-set-migration.html\">section 11</a>) the database character set encoding.</li>\n<li>SQLite users, there is nothing you need to do. SQLite always uses UTF-8\nfor internal encoding.</li>\n</ul>\n<p>All of Django\u2019s database backends automatically convert strings into\nthe appropriate encoding for talking to the database. They also automatically\nconvert strings retrieved from the database into strings. You don\u2019t even need\nto tell Django what encoding your database uses: that is handled transparently.</p>\n<p>For more, see the section \u201cThe database API\u201d below.</p>\n</div>\n<div class=\"section\" id=\"s-general-string-handling\">\n<span id=\"general-string-handling\"></span><h2>General string handling<a class=\"headerlink\" href=\"#general-string-handling\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Whenever you use strings with Django \u2013 e.g., in database lookups, template\nrendering or anywhere else \u2013 you have two choices for encoding those strings.\nYou can use normal strings or bytestrings (starting with a \u2018b\u2019).</p>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p>A bytestring does not carry any information with it about its encoding.\nFor that reason, we have to make an assumption, and Django assumes that all\nbytestrings are in UTF-8.</p>\n<p class=\"last\">If you pass a string to Django that has been encoded in some other format,\nthings will go wrong in interesting ways. Usually, Django will raise a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">UnicodeDecodeError</span></code> at some point.</p>\n</div>\n<p>If your code only uses ASCII data, it\u2019s safe to use your normal strings,\npassing them around at will, because ASCII is a subset of UTF-8.</p>\n<p>Don\u2019t be fooled into thinking that if your <a class=\"reference internal\" href=\"../settings/#std-setting-DEFAULT_CHARSET\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEFAULT_CHARSET</span></code></a> setting is set\nto something other than <code class=\"docutils literal notranslate\"><span class=\"pre\">'utf-8'</span></code> you can use that other encoding in your\nbytestrings! <a class=\"reference internal\" href=\"../settings/#std-setting-DEFAULT_CHARSET\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEFAULT_CHARSET</span></code></a> only applies to the strings generated as\nthe result of template rendering (and email). Django will always assume UTF-8\nencoding for internal bytestrings. The reason for this is that the\n<a class=\"reference internal\" href=\"../settings/#std-setting-DEFAULT_CHARSET\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEFAULT_CHARSET</span></code></a> setting is not actually under your control (if you are the\napplication developer). It\u2019s under the control of the person installing and\nusing your application \u2013 and if that person chooses a different setting, your\ncode must still continue to work. Ergo, it cannot rely on that setting.</p>\n<p>In most cases when Django is dealing with strings, it will convert them to\nstrings before doing anything else. So, as a general rule, if you pass\nin a bytestring, be prepared to receive a string back in the result.</p>\n<div class=\"section\" id=\"s-translated-strings\">\n<span id=\"translated-strings\"></span><h3>Translated strings<a class=\"headerlink\" href=\"#translated-strings\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Aside from strings and bytestrings, there\u2019s a third type of string-like\nobject you may encounter when using Django. The framework\u2019s\ninternationalization features introduce the concept of a \u201clazy translation\u201d \u2013\na string that has been marked as translated but whose actual translation result\nisn\u2019t determined until the object is used in a string. This feature is useful\nin cases where the translation locale is unknown until the string is used, even\nthough the string might have originally been created when the code was first\nimported.</p>\n<p>Normally, you won\u2019t have to worry about lazy translations. Just be aware that\nif you examine an object and it claims to be a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">django.utils.functional.__proxy__</span></code> object, it is a lazy translation.\nCalling <code class=\"docutils literal notranslate\"><span class=\"pre\">str()</span></code> with the lazy translation as the argument will generate a\nstring in the current locale.</p>\n<p>For more details about lazy translation objects, refer to the\n<a class=\"reference internal\" href=\"../../topics/i18n/\"><span class=\"doc\">internationalization</span></a> documentation.</p>\n</div>\n<div class=\"section\" id=\"s-useful-utility-functions\">\n<span id=\"useful-utility-functions\"></span><h3>Useful utility functions<a class=\"headerlink\" href=\"#useful-utility-functions\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Because some string operations come up again and again, Django ships with a few\nuseful functions that should make working with string and bytestring objects\na bit easier.</p>\n<div class=\"section\" id=\"s-conversion-functions\">\n<span id=\"conversion-functions\"></span><h4>Conversion functions<a class=\"headerlink\" href=\"#conversion-functions\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">django.utils.encoding</span></code> module contains a few functions that are handy\nfor converting back and forth between strings and bytestrings.</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str(s,</span> <span class=\"pre\">encoding='utf-8',</span> <span class=\"pre\">strings_only=False,</span> <span class=\"pre\">errors='strict')</span></code>\nconverts its input to a string. The <code class=\"docutils literal notranslate\"><span class=\"pre\">encoding</span></code> parameter\nspecifies the input encoding. (For example, Django uses this internally\nwhen processing form input data, which might not be UTF-8 encoded.) The\n<code class=\"docutils literal notranslate\"><span class=\"pre\">strings_only</span></code> parameter, if set to True, will result in Python\nnumbers, booleans and <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> not being converted to a string (they keep\ntheir original types). The <code class=\"docutils literal notranslate\"><span class=\"pre\">errors</span></code> parameter takes any of the values\nthat are accepted by Python\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">str()</span></code> function for its error\nhandling.</li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">force_str(s,</span> <span class=\"pre\">encoding='utf-8',</span> <span class=\"pre\">strings_only=False,</span> <span class=\"pre\">errors='strict')</span></code> is\nidentical to <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code> in almost all cases. The difference is when the\nfirst argument is a <a class=\"reference internal\" href=\"../../topics/i18n/translation/#lazy-translations\"><span class=\"std std-ref\">lazy translation</span></a> instance.\nWhile <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code> preserves lazy translations, <code class=\"docutils literal notranslate\"><span class=\"pre\">force_str()</span></code> forces\nthose objects to a string (causing the translation to occur). Normally,\nyou\u2019ll want to use <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code>. However, <code class=\"docutils literal notranslate\"><span class=\"pre\">force_str()</span></code> is useful in\ntemplate tags and filters that absolutely <em>must</em> have a string to work with,\nnot just something that can be converted to a string.</li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">smart_bytes(s,</span> <span class=\"pre\">encoding='utf-8',</span> <span class=\"pre\">strings_only=False,</span> <span class=\"pre\">errors='strict')</span></code>\nis essentially the opposite of <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code>. It forces the first\nargument to a bytestring. The <code class=\"docutils literal notranslate\"><span class=\"pre\">strings_only</span></code> parameter has the same\nbehavior as for <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">force_str()</span></code>. This is\nslightly different semantics from Python\u2019s builtin <code class=\"docutils literal notranslate\"><span class=\"pre\">str()</span></code> function,\nbut the difference is needed in a few places within Django\u2019s internals.</li>\n</ul>\n<p>Normally, you\u2019ll only need to use <code class=\"docutils literal notranslate\"><span class=\"pre\">force_str()</span></code>. Call it as early as\npossible on any input data that might be either a string or a bytestring, and\nfrom then on, you can treat the result as always being a string.</p>\n</div>\n<div class=\"section\" id=\"s-uri-and-iri-handling\">\n<span id=\"s-id1\"></span><span id=\"uri-and-iri-handling\"></span><span id=\"id1\"></span><h4>URI and IRI handling<a class=\"headerlink\" href=\"#uri-and-iri-handling\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>Web frameworks have to deal with URLs (which are a type of IRI). One\nrequirement of URLs is that they are encoded using only ASCII characters.\nHowever, in an international environment, you might need to construct a\nURL from an <span class=\"target\" id=\"index-0\"></span><a class=\"rfc reference external\" href=\"https://datatracker.ietf.org/doc/html/rfc3987.html\"><strong>IRI</strong></a> \u2013 very loosely speaking, a <span class=\"target\" id=\"index-1\"></span><a class=\"rfc reference external\" href=\"https://datatracker.ietf.org/doc/html/rfc3986.html\"><strong>URI</strong></a>\nthat can contain Unicode characters. Use these functions for quoting and\nconverting an IRI to a URI:</p>\n<ul class=\"simple\">\n<li>The <a class=\"reference internal\" href=\"../utils/#django.utils.encoding.iri_to_uri\" title=\"django.utils.encoding.iri_to_uri\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">django.utils.encoding.iri_to_uri()</span></code></a> function, which implements the\nconversion from IRI to URI as required by <span class=\"target\" id=\"index-2\"></span><a class=\"rfc reference external\" href=\"https://datatracker.ietf.org/doc/html/rfc3987.html#section-3.1\"><strong>RFC 3987#section-3.1</strong></a>.</li>\n<li>The <a class=\"reference external\" href=\"https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote\" title=\"(in Python v3.11)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">urllib.parse.quote()</span></code></a> and <a class=\"reference external\" href=\"https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote_plus\" title=\"(in Python v3.11)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">urllib.parse.quote_plus()</span></code></a>\nfunctions from Python\u2019s standard library.</li>\n</ul>\n<p>These two groups of functions have slightly different purposes, and it\u2019s\nimportant to keep them straight. Normally, you would use <code class=\"docutils literal notranslate\"><span class=\"pre\">quote()</span></code> on the\nindividual portions of the IRI or URI path so that any reserved characters\nsuch as \u2018&amp;\u2019 or \u2018%\u2019 are correctly encoded. Then, you apply <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> to\nthe full IRI and it converts any non-ASCII characters to the correct encoded\nvalues.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Technically, it isn\u2019t correct to say that <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> implements the\nfull algorithm in the IRI specification. It doesn\u2019t (yet) perform the\ninternational domain name encoding portion of the algorithm.</p>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> function will not change ASCII characters that are\notherwise permitted in a URL. So, for example, the character \u2018%\u2019 is not\nfurther encoded when passed to <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code>. This means you can pass a\nfull URL to this function and it will not mess up the query string or anything\nlike that.</p>\n<p>An example might clarify things here:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">urllib.parse</span> <span class=\"kn\">import</span> <span class=\"n\">quote</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.utils.encoding</span> <span class=\"kn\">import</span> <span class=\"n\">iri_to_uri</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">quote</span><span class=\"p\">(</span><span class=\"s2\">&quot;Paris &amp; Orl\u00e9ans&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">&#39;Paris%20%26%20Orl%C3%A9ans&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">iri_to_uri</span><span class=\"p\">(</span><span class=\"s2\">&quot;/favorites/Fran\u00e7ois/</span><span class=\"si\">%s</span><span class=\"s2\">&quot;</span> <span class=\"o\">%</span> <span class=\"n\">quote</span><span class=\"p\">(</span><span class=\"s2\">&quot;Paris &amp; Orl\u00e9ans&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">&#39;/favorites/Fran%C3%A7ois/Paris%20%26%20Orl%C3%A9ans&#39;</span>\n</pre></div>\n</div>\n<p>If you look carefully, you can see that the portion that was generated by\n<code class=\"docutils literal notranslate\"><span class=\"pre\">quote()</span></code> in the second example was not double-quoted when passed to\n<code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code>. This is a very important and useful feature. It means that\nyou can construct your IRI without worrying about whether it contains\nnon-ASCII characters and then, right at the end, call <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> on the\nresult.</p>\n<p>Similarly, Django provides <a class=\"reference internal\" href=\"../utils/#django.utils.encoding.uri_to_iri\" title=\"django.utils.encoding.uri_to_iri\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">django.utils.encoding.uri_to_iri()</span></code></a> which\nimplements the conversion from URI to IRI as per <span class=\"target\" id=\"index-3\"></span><a class=\"rfc reference external\" href=\"https://datatracker.ietf.org/doc/html/rfc3987.html#section-3.2\"><strong>RFC 3987#section-3.2</strong></a>.</p>\n<p>An example to demonstrate:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.utils.encoding</span> <span class=\"kn\">import</span> <span class=\"n\">uri_to_iri</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">uri_to_iri</span><span class=\"p\">(</span><span class=\"s2\">&quot;/</span><span class=\"si\">%E</span><span class=\"s2\">2</span><span class=\"si\">%99%</span><span class=\"s2\">A5</span><span class=\"si\">%E</span><span class=\"s2\">2</span><span class=\"si\">%99%</span><span class=\"s2\">A5/?utf8=</span><span class=\"si\">%E</span><span class=\"s2\">2%9C%93&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">&#39;/\u2665\u2665/?utf8=\u2713&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">uri_to_iri</span><span class=\"p\">(</span><span class=\"s2\">&quot;%A9hello</span><span class=\"si\">%3F</span><span class=\"s2\">world&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">&#39;%A9hello%3Fworld&#39;</span>\n</pre></div>\n</div>\n<p>In the first example, the UTF-8 characters are unquoted. In the second, the\npercent-encodings remain unchanged because they lie outside the valid UTF-8\nrange or represent a reserved character.</p>\n<p>Both <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">uri_to_iri()</span></code> functions are idempotent, which means the\nfollowing is always true:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">iri_to_uri</span><span class=\"p\">(</span><span class=\"n\">iri_to_uri</span><span class=\"p\">(</span><span class=\"n\">some_string</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">iri_to_uri</span><span class=\"p\">(</span><span class=\"n\">some_string</span><span class=\"p\">)</span>\n<span class=\"n\">uri_to_iri</span><span class=\"p\">(</span><span class=\"n\">uri_to_iri</span><span class=\"p\">(</span><span class=\"n\">some_string</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">uri_to_iri</span><span class=\"p\">(</span><span class=\"n\">some_string</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>So you can safely call it multiple times on the same URI/IRI without risking\ndouble-quoting problems.</p>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-models\">\n<span id=\"models\"></span><h2>Models<a class=\"headerlink\" href=\"#models\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Because all strings are returned from the database as <code class=\"docutils literal notranslate\"><span class=\"pre\">str</span></code> objects, model\nfields that are character based (CharField, TextField, URLField, etc.) will\ncontain Unicode values when Django retrieves data from the database. This\nis <em>always</em> the case, even if the data could fit into an ASCII bytestring.</p>\n<p>You can pass in bytestrings when creating a model or populating a field, and\nDjango will convert it to strings when it needs to.</p>\n<div class=\"section\" id=\"s-taking-care-in-get-absolute-url\">\n<span id=\"taking-care-in-get-absolute-url\"></span><h3>Taking care in <code class=\"docutils literal notranslate\"><span class=\"pre\">get_absolute_url()</span></code><a class=\"headerlink\" href=\"#taking-care-in-get-absolute-url\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>URLs can only contain ASCII characters. If you\u2019re constructing a URL from\npieces of data that might be non-ASCII, be careful to encode the results in a\nway that is suitable for a URL. The <a class=\"reference internal\" href=\"../urlresolvers/#django.urls.reverse\" title=\"django.urls.reverse\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">reverse()</span></code></a> function\nhandles this for you automatically.</p>\n<p>If you\u2019re constructing a URL manually (i.e., <em>not</em> using the <code class=\"docutils literal notranslate\"><span class=\"pre\">reverse()</span></code>\nfunction), you\u2019ll need to take care of the encoding yourself. In this case,\nuse the <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">quote()</span></code> functions that were documented\n<a class=\"reference internal\" href=\"#id1\">above</a>. For example:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">urllib.parse</span> <span class=\"kn\">import</span> <span class=\"n\">quote</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.utils.encoding</span> <span class=\"kn\">import</span> <span class=\"n\">iri_to_uri</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_absolute_url</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/person/</span><span class=\"si\">%s</span><span class=\"s2\">/?x=0&amp;y=0&quot;</span> <span class=\"o\">%</span> <span class=\"n\">quote</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">location</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">iri_to_uri</span><span class=\"p\">(</span><span class=\"n\">url</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>This function returns a correctly encoded URL even if <code class=\"docutils literal notranslate\"><span class=\"pre\">self.location</span></code> is\nsomething like \u201cJack visited Paris &amp; Orl\u00e9ans\u201d. (In fact, the <code class=\"docutils literal notranslate\"><span class=\"pre\">iri_to_uri()</span></code>\ncall isn\u2019t strictly necessary in the above example, because all the\nnon-ASCII characters would have been removed in quoting in the first line.)</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-templates\">\n<span id=\"templates\"></span><h2>Templates<a class=\"headerlink\" href=\"#templates\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Use strings when creating templates manually:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.template</span> <span class=\"kn\">import</span> <span class=\"n\">Template</span>\n\n<span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">Template</span><span class=\"p\">(</span><span class=\"s2\">&quot;This is a string template.&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>But the common case is to read templates from the filesystem. If your template\nfiles are not stored with a UTF-8 encoding, adjust the <a class=\"reference internal\" href=\"../settings/#std-setting-TEMPLATES\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">TEMPLATES</span></code></a>\nsetting. The built-in <a class=\"reference internal\" href=\"../../topics/templates/#module-django.template.backends.django\" title=\"django.template.backends.django\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">django</span></code></a> backend\nprovides the <code class=\"docutils literal notranslate\"><span class=\"pre\">'file_charset'</span></code> option to change the encoding used to read\nfiles from disk.</p>\n<p>The <a class=\"reference internal\" href=\"../settings/#std-setting-DEFAULT_CHARSET\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEFAULT_CHARSET</span></code></a> setting controls the encoding of rendered templates.\nThis is set to UTF-8 by default.</p>\n<div class=\"section\" id=\"s-template-tags-and-filters\">\n<span id=\"template-tags-and-filters\"></span><h3>Template tags and filters<a class=\"headerlink\" href=\"#template-tags-and-filters\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>A couple of tips to remember when writing your own template tags and filters:</p>\n<ul class=\"simple\">\n<li>Always return strings from a template tag\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">render()</span></code> method\nand from template filters.</li>\n<li>Use <code class=\"docutils literal notranslate\"><span class=\"pre\">force_str()</span></code> in preference to <code class=\"docutils literal notranslate\"><span class=\"pre\">smart_str()</span></code> in these\nplaces. Tag rendering and filter calls occur as the template is being\nrendered, so there is no advantage to postponing the conversion of lazy\ntranslation objects into strings. It\u2019s easier to work solely with\nstrings at that point.</li>\n</ul>\n</div>\n</div>\n<div class=\"section\" id=\"s-files\">\n<span id=\"s-unicode-files\"></span><span id=\"files\"></span><span id=\"unicode-files\"></span><h2>Files<a class=\"headerlink\" href=\"#files\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>If you intend to allow users to upload files, you must ensure that the\nenvironment used to run Django is configured to work with non-ASCII file names.\nIf your environment isn\u2019t configured correctly, you\u2019ll encounter\n<code class=\"docutils literal notranslate\"><span class=\"pre\">UnicodeEncodeError</span></code> exceptions when saving files with file names or content\nthat contains non-ASCII characters.</p>\n<p>Filesystem support for UTF-8 file names varies and might depend on the\nenvironment. Check your current configuration in an interactive Python shell by\nrunning:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getfilesystemencoding</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>This should output \u201cUTF-8\u201d.</p>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">LANG</span></code> environment variable is responsible for setting the expected\nencoding on Unix platforms. Consult the documentation for your operating system\nand application server for the appropriate syntax and location to set this\nvariable. See the <a class=\"reference internal\" href=\"../../howto/deployment/wsgi/modwsgi/\"><span class=\"doc\">How to use Django with Apache and mod_wsgi</span></a> for examples.</p>\n<p>In your development environment, you might need to add a setting to your\n<code class=\"docutils literal notranslate\"><span class=\"pre\">~.bashrc</span></code> analogous to:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">export</span> <span class=\"nv\">LANG</span><span class=\"o\">=</span><span class=\"s2\">&quot;en_US.UTF-8&quot;</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-form-submission\">\n<span id=\"form-submission\"></span><h2>Form submission<a class=\"headerlink\" href=\"#form-submission\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>HTML form submission is a tricky area. There\u2019s no guarantee that the\nsubmission will include encoding information, which means the framework might\nhave to guess at the encoding of submitted data.</p>\n<p>Django adopts a \u201clazy\u201d approach to decoding form data. The data in an\n<code class=\"docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code> object is only decoded when you access it. In fact, most of\nthe data is not decoded at all. Only the <code class=\"docutils literal notranslate\"><span class=\"pre\">HttpRequest.GET</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">HttpRequest.POST</span></code> data structures have any decoding applied to them. Those\ntwo fields will return their members as Unicode data. All other attributes and\nmethods of <code class=\"docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code> return data exactly as it was submitted by the\nclient.</p>\n<p>By default, the <a class=\"reference internal\" href=\"../settings/#std-setting-DEFAULT_CHARSET\"><code class=\"xref std std-setting docutils literal notranslate\"><span class=\"pre\">DEFAULT_CHARSET</span></code></a> setting is used as the assumed encoding\nfor form data. If you need to change this for a particular form, you can set\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">encoding</span></code> attribute on an <code class=\"docutils literal notranslate\"><span class=\"pre\">HttpRequest</span></code> instance. For example:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">some_view</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># We know that the data must be encoded as KOI8-R (for some reason).</span>\n    <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">encoding</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;koi8-r&quot;</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>You can even change the encoding after having accessed <code class=\"docutils literal notranslate\"><span class=\"pre\">request.GET</span></code> or\n<code class=\"docutils literal notranslate\"><span class=\"pre\">request.POST</span></code>, and all subsequent accesses will use the new encoding.</p>\n<p>Most developers won\u2019t need to worry about changing form encoding, but this is\na useful feature for applications that talk to legacy systems whose encoding\nyou cannot control.</p>\n<p>Django does not decode the data of file uploads, because that data is normally\ntreated as collections of bytes, rather than strings. Any automatic decoding\nthere would alter the meaning of the stream of bytes.</p>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["ref/urlresolvers", "<code class=\"docutils literal notranslate\"><span class=\"pre\">django.urls</span></code> utility functions", "N", "next"], ["ref/template-response", "<code class=\"docutils literal notranslate\"><span class=\"pre\">TemplateResponse</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">SimpleTemplateResponse</span></code>", "P", "previous"]], "sourcename": "ref/unicode.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Unicode data</a><ul>\n<li><a class=\"reference internal\" href=\"#creating-the-database\">Creating the database</a></li>\n<li><a class=\"reference internal\" href=\"#general-string-handling\">General string handling</a><ul>\n<li><a class=\"reference internal\" href=\"#translated-strings\">Translated strings</a></li>\n<li><a class=\"reference internal\" href=\"#useful-utility-functions\">Useful utility functions</a><ul>\n<li><a class=\"reference internal\" href=\"#conversion-functions\">Conversion functions</a></li>\n<li><a class=\"reference internal\" href=\"#uri-and-iri-handling\">URI and IRI handling</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#models\">Models</a><ul>\n<li><a class=\"reference internal\" href=\"#taking-care-in-get-absolute-url\">Taking care in <code class=\"docutils literal notranslate\"><span class=\"pre\">get_absolute_url()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#templates\">Templates</a><ul>\n<li><a class=\"reference internal\" href=\"#template-tags-and-filters\">Template tags and filters</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#files\">Files</a></li>\n<li><a class=\"reference internal\" href=\"#form-submission\">Form submission</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "ref/unicode", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}
