{"parents": [{"link": "../../../", "title": "Module code"}, {"link": "../../", "title": "django"}], "title": "django.utils.functional", "body": "<h1>Source code for django.utils.functional</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"kn\">import</span> <span class=\"nn\">copy</span>\n<span class=\"kn\">import</span> <span class=\"nn\">itertools</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">wraps</span>\n\n\n<div class=\"viewcode-block\" id=\"cached_property\"><a class=\"viewcode-back\" href=\"../../../../ref/utils/#django.utils.functional.cached_property\">[docs]</a><span class=\"k\">class</span> <span class=\"nc\">cached_property</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Decorator that converts a method with a single self argument into a</span>\n<span class=\"sd\">    property cached on the instance.</span>\n\n<span class=\"sd\">    A cached property can be made out of an existing method:</span>\n<span class=\"sd\">    (e.g. ``url = cached_property(get_absolute_url)``).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n            <span class=\"s2\">&quot;Cannot use cached_property instance without calling &quot;</span>\n            <span class=\"s2\">&quot;__set_name__() on it.&quot;</span>\n        <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">real_func</span> <span class=\"o\">=</span> <span class=\"n\">func</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"s2\">&quot;__doc__&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__set_name__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">real_func</span>\n        <span class=\"k\">elif</span> <span class=\"n\">name</span> <span class=\"o\">!=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                <span class=\"s2\">&quot;Cannot assign the same cached_property to two different names &quot;</span>\n                <span class=\"s2\">&quot;(</span><span class=\"si\">%r</span><span class=\"s2\"> and </span><span class=\"si\">%r</span><span class=\"s2\">).&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n            <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__get__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Call the function and put the return value in instance.__dict__ so that</span>\n<span class=\"sd\">        subsequent attribute access on the instance returns the cached value</span>\n<span class=\"sd\">        instead of calling cached_property.__get__().</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">if</span> <span class=\"n\">instance</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">instance</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span></div>\n\n\n<div class=\"viewcode-block\" id=\"classproperty\"><a class=\"viewcode-back\" href=\"../../../../ref/utils/#django.utils.functional.classproperty\">[docs]</a><span class=\"k\">class</span> <span class=\"nc\">classproperty</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Decorator that converts a method with a single cls argument into a property</span>\n<span class=\"sd\">    that can be accessed directly from the class.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fget</span> <span class=\"o\">=</span> <span class=\"n\">method</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__get__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fget</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">getter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">method</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fget</span> <span class=\"o\">=</span> <span class=\"n\">method</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span></div>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Promise</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Base class for the proxy class created in the closure of the lazy function.</span>\n<span class=\"sd\">    It&#39;s used to recognize promises in code.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">pass</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Turn any callable into a lazy evaluated callable. result classes or types</span>\n<span class=\"sd\">    is required -- at least one is needed so that the automatic forcing of</span>\n<span class=\"sd\">    the lazy evaluation code is triggered. Results are not memoized; the</span>\n<span class=\"sd\">    function is evaluated on every access.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">__proxy__</span><span class=\"p\">(</span><span class=\"n\">Promise</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Encapsulate a function call and act as a proxy for methods that are</span>\n<span class=\"sd\">        called on the result of that function. The function is not evaluated</span>\n<span class=\"sd\">        until one of the methods on the result is called.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kw</span><span class=\"p\">):</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_args</span> <span class=\"o\">=</span> <span class=\"n\">args</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_kw</span> <span class=\"o\">=</span> <span class=\"n\">kw</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">(</span>\n                <span class=\"n\">_lazy_proxy_unpickle</span><span class=\"p\">,</span>\n                <span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_args</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_kw</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">resultclasses</span><span class=\"p\">,</span>\n            <span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Instances of this class are effectively immutable. It&#39;s just a</span>\n            <span class=\"c1\"># collection of functions. So we don&#39;t need to do anything</span>\n            <span class=\"c1\"># complicated for copying.</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__cast</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_kw</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Explicitly wrap methods which are defined on object and hence would</span>\n        <span class=\"c1\"># not have been overloaded by the loop over resultclasses below.</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__str__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__ne__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__lt__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__le__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">&lt;=</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__gt__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__ge__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">&gt;=</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__format__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">format_spec</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">(),</span> <span class=\"n\">format_spec</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Explicitly wrap methods which are required for certain operations on</span>\n        <span class=\"c1\"># int/str objects to function correctly.</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__add__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__radd__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">other</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__mod__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">%</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"fm\">__mul__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">*</span> <span class=\"n\">other</span>\n\n    <span class=\"c1\"># Add wrappers for all methods from resultclasses which haven&#39;t been</span>\n    <span class=\"c1\"># wrapped explicitly above.</span>\n    <span class=\"k\">for</span> <span class=\"n\">resultclass</span> <span class=\"ow\">in</span> <span class=\"n\">resultclasses</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">type_</span> <span class=\"ow\">in</span> <span class=\"n\">resultclass</span><span class=\"o\">.</span><span class=\"n\">mro</span><span class=\"p\">():</span>\n            <span class=\"k\">for</span> <span class=\"n\">method_name</span> <span class=\"ow\">in</span> <span class=\"n\">type_</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n                <span class=\"c1\"># All __promise__ return the same wrapper method, they look up</span>\n                <span class=\"c1\"># the correct implementation when called.</span>\n                <span class=\"k\">if</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">__proxy__</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">):</span>\n                    <span class=\"k\">continue</span>\n\n                <span class=\"c1\"># Builds a wrapper around some method. Pass method_name to</span>\n                <span class=\"c1\"># avoid issues due to late binding.</span>\n                <span class=\"k\">def</span> <span class=\"nf\">__wrapper__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">__method_name</span><span class=\"o\">=</span><span class=\"n\">method_name</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">):</span>\n                    <span class=\"c1\"># Automatically triggers the evaluation of a lazy value and</span>\n                    <span class=\"c1\"># applies the given method of the result type.</span>\n                    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_kw</span><span class=\"p\">)</span>\n                    <span class=\"k\">return</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">__method_name</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">)</span>\n\n                <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"n\">__proxy__</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">,</span> <span class=\"n\">__wrapper__</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__wrapper__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Creates the proxy object, instead of the actual value.</span>\n        <span class=\"k\">return</span> <span class=\"n\">__proxy__</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kw</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">__wrapper__</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_lazy_proxy_unpickle</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">lazystr</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Shortcut for the common case of a lazy callable that returns str.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">)(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n\n<div class=\"viewcode-block\" id=\"keep_lazy\"><a class=\"viewcode-back\" href=\"../../../../ref/utils/#django.utils.functional.keep_lazy\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">keep_lazy</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A decorator that allows a function to be called with one or more lazy</span>\n<span class=\"sd\">    arguments. If none of the args are lazy, the function is evaluated</span>\n<span class=\"sd\">    immediately, otherwise a __proxy__ is returned that will evaluate the</span>\n<span class=\"sd\">    function when needed.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">resultclasses</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;You must pass at least one argument to keep_lazy().&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">decorator</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n        <span class=\"n\">lazy_func</span> <span class=\"o\">=</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">)</span>\n\n        <span class=\"nd\">@wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n        <span class=\"k\">def</span> <span class=\"nf\">wrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">any</span><span class=\"p\">(</span>\n                <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">)</span>\n                <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"o\">.</span><span class=\"n\">chain</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>\n            <span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"n\">lazy_func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">wrapper</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">decorator</span></div>\n\n\n<div class=\"viewcode-block\" id=\"keep_lazy_text\"><a class=\"viewcode-back\" href=\"../../../../ref/utils/#django.utils.functional.keep_lazy_text\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">keep_lazy_text</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A decorator for functions that accept lazy arguments and return text.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">keep_lazy</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)(</span><span class=\"n\">func</span><span class=\"p\">)</span></div>\n\n\n<span class=\"n\">empty</span> <span class=\"o\">=</span> <span class=\"nb\">object</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_wrapped</span> <span class=\"o\">:=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n            <span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span>\n\n    <span class=\"n\">inner</span><span class=\"o\">.</span><span class=\"n\">_mask_wrapped</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"k\">return</span> <span class=\"n\">inner</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">LazyObject</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A wrapper for another class that can be used to delay instantiation of the</span>\n<span class=\"sd\">    wrapped class.</span>\n\n<span class=\"sd\">    By subclassing, you have the opportunity to intercept and alter the</span>\n<span class=\"sd\">    instantiation. If you don&#39;t need to do that, use SimpleLazyObject.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"c1\"># Avoid infinite recursion when tracing __init__ (#19456).</span>\n    <span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Note: if a subclass overrides __init__(), it will likely need to</span>\n        <span class=\"c1\"># override __copy__() and __deepcopy__() as well.</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"n\">empty</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getattribute__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Avoid recursion when getting wrapped object.</span>\n            <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__getattribute__</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__getattribute__</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span>\n        <span class=\"c1\"># If attribute is a proxy method, raise an AttributeError to call</span>\n        <span class=\"c1\"># __getattr__() and use the wrapped object method.</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"s2\">&quot;_mask_wrapped&quot;</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span>\n\n    <span class=\"fm\">__getattr__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">getattr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__setattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Assign to __dict__ to avoid infinite __setattr__ loops.</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n            <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__delattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;can&#39;t delete _wrapped.&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"nb\">delattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Must be implemented by subclasses to initialize the wrapped object.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span>\n            <span class=\"s2\">&quot;subclasses of LazyObject must provide a _setup() method&quot;</span>\n        <span class=\"p\">)</span>\n\n    <span class=\"c1\"># Because we have messed with __class__ below, we confuse pickle as to what</span>\n    <span class=\"c1\"># class we are pickling. We&#39;re going to have to initialize the wrapped</span>\n    <span class=\"c1\"># object to successfully pickle it, so we might as well just pickle the</span>\n    <span class=\"c1\"># wrapped object since they&#39;re supposed to act the same way.</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># Unfortunately, if we try to simply act like the wrapped object, the ruse</span>\n    <span class=\"c1\"># will break down when pickle gets our id(). Thus we end up with pickle</span>\n    <span class=\"c1\"># thinking, in effect, that we are a distinct object from the wrapped</span>\n    <span class=\"c1\"># object, but with the same __dict__. This can cause problems (see #25389).</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># So instead, we define our own __reduce__ method and custom unpickler. We</span>\n    <span class=\"c1\"># pickle the wrapped object as the unpickler&#39;s argument, so that pickle</span>\n    <span class=\"c1\"># will pickle it normally, and then the unpickler simply returns its</span>\n    <span class=\"c1\"># argument.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">unpickle_lazyobject</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If uninitialized, copy the wrapper. Use type(self), not</span>\n            <span class=\"c1\"># self.__class__, because the latter is proxied.</span>\n            <span class=\"k\">return</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)()</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If initialized, return a copy of the wrapped object.</span>\n            <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># We have to use type(self), not self.__class__, because the</span>\n            <span class=\"c1\"># latter is proxied.</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)()</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">result</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">deepcopy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">)</span>\n\n    <span class=\"fm\">__bytes__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">bytes</span><span class=\"p\">)</span>\n    <span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)</span>\n    <span class=\"fm\">__bool__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">bool</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Introspection support</span>\n    <span class=\"fm\">__dir__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">dir</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Need to pretend to be the wrapped class, for the sake of objects that</span>\n    <span class=\"c1\"># care about this (especially in equality tests)</span>\n    <span class=\"vm\">__class__</span> <span class=\"o\">=</span> <span class=\"nb\">property</span><span class=\"p\">(</span><span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">attrgetter</span><span class=\"p\">(</span><span class=\"s2\">&quot;__class__&quot;</span><span class=\"p\">)))</span>\n    <span class=\"fm\">__eq__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">eq</span><span class=\"p\">)</span>\n    <span class=\"fm\">__lt__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">lt</span><span class=\"p\">)</span>\n    <span class=\"fm\">__gt__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">gt</span><span class=\"p\">)</span>\n    <span class=\"fm\">__ne__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">ne</span><span class=\"p\">)</span>\n    <span class=\"fm\">__hash__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># List/Tuple/Dictionary methods support</span>\n    <span class=\"fm\">__getitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">getitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__setitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">setitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__delitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">delitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__iter__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">)</span>\n    <span class=\"fm\">__len__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">)</span>\n    <span class=\"fm\">__contains__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">unpickle_lazyobject</span><span class=\"p\">(</span><span class=\"n\">wrapped</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Used to unpickle lazy objects. Just return its argument, which will be the</span>\n<span class=\"sd\">    wrapped object.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">wrapped</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"n\">LazyObject</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A lazy object initialized from any function.</span>\n\n<span class=\"sd\">    Designed for compound objects of unknown type. For builtins or objects of</span>\n<span class=\"sd\">    known type, use django.utils.functional.lazy.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Pass in a callable that returns the object to be wrapped.</span>\n\n<span class=\"sd\">        If copies are made of the resulting SimpleLazyObject, which can happen</span>\n<span class=\"sd\">        in various circumstances within Django, then you must ensure that the</span>\n<span class=\"sd\">        callable can be safely run more than once and will return the same</span>\n<span class=\"sd\">        value.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"s2\">&quot;_setupfunc&quot;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">func</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Return a meaningful representation of the lazy object for debugging</span>\n    <span class=\"c1\"># without evaluating the wrapped object.</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"n\">repr_attr</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">repr_attr</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span>\n        <span class=\"k\">return</span> <span class=\"s2\">&quot;&lt;</span><span class=\"si\">%s</span><span class=\"s2\">: </span><span class=\"si\">%r</span><span class=\"s2\">&gt;&quot;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">,</span> <span class=\"n\">repr_attr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If uninitialized, copy the wrapper. Use SimpleLazyObject, not</span>\n            <span class=\"c1\"># self.__class__, because the latter is proxied.</span>\n            <span class=\"k\">return</span> <span class=\"n\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If initialized, return a copy of the wrapped object.</span>\n            <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># We have to use SimpleLazyObject, not self.__class__, because the</span>\n            <span class=\"c1\"># latter is proxied.</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">)</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">result</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">deepcopy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">)</span>\n\n    <span class=\"fm\">__add__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@new_method_proxy</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__radd__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">other</span> <span class=\"o\">+</span> <span class=\"bp\">self</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">partition</span><span class=\"p\">(</span><span class=\"n\">predicate</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Split the values into two sets, based on the return value of the function</span>\n<span class=\"sd\">    (True/False). e.g.:</span>\n\n<span class=\"sd\">        &gt;&gt;&gt; partition(lambda x: x &gt; 3, range(5))</span>\n<span class=\"sd\">        [0, 1, 2, 3], [4]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"p\">([],</span> <span class=\"p\">[])</span>\n    <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">:</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">predicate</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n</pre></div>", "current_page_name": "_modules/django/utils/functional", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}
