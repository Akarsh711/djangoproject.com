{"parents": [{"link": "../", "title": "Using Django"}], "prev": {"link": "../external-packages/", "title": "External packages"}, "next": {"link": "../../howto/", "title": "\u201cHow-to\u201d guides"}, "title": "Asynchronous support", "meta": {}, "body": "<div class=\"section\" id=\"s-asynchronous-support\">\n<span id=\"asynchronous-support\"></span><h1>Asynchronous support<a class=\"headerlink\" href=\"#asynchronous-support\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Django has support for writing asynchronous (\u201casync\u201d) views, along with an\nentirely async-enabled request stack if you are running under\n<a class=\"reference internal\" href=\"../../howto/deployment/asgi/\"><span class=\"doc\">ASGI</span></a>. Async views will still work under\nWSGI, but with performance penalties, and without the ability to have efficient\nlong-running requests.</p>\n<p>We\u2019re still working on async support for the ORM and other parts of Django.\nYou can expect to see this in future releases. For now, you can use the\n<a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> adapter to interact with the sync parts of Django.\nThere is also a whole range of async-native Python libraries that you can\nintegrate with.</p>\n<div class=\"section\" id=\"s-async-views\">\n<span id=\"async-views\"></span><h2>Async views<a class=\"headerlink\" href=\"#async-views\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Any view can be declared async by making the callable part of it return a\ncoroutine - commonly, this is done using <code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code>. For a function-based\nview, this means declaring the whole view using <code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code>. For a\nclass-based view, this means declaring the HTTP method handlers, such as\n<code class=\"docutils literal notranslate\"><span class=\"pre\">get()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">post()</span></code> as <code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code> (not its <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__()</span></code>, or\n<code class=\"docutils literal notranslate\"><span class=\"pre\">as_view()</span></code>).</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Django uses <code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref.sync.iscoroutinefunction</span></code> to test if your view is\nasynchronous or not. If you implement your own method of returning a\ncoroutine, ensure you use <code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref.sync.markcoroutinefunction</span></code> so this\nfunction returns <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>.</p>\n</div>\n<p>Under a WSGI server, async views will run in their own, one-off event loop.\nThis means you can use async features, like concurrent async HTTP requests,\nwithout any issues, but you will not get the benefits of an async stack.</p>\n<p>The main benefits are the ability to service hundreds of connections without\nusing Python threads. This allows you to use slow streaming, long-polling, and\nother exciting response types.</p>\n<p>If you want to use these, you will need to deploy Django using\n<a class=\"reference internal\" href=\"../../howto/deployment/asgi/\"><span class=\"doc\">ASGI</span></a> instead.</p>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p>You will only get the benefits of a fully-asynchronous request stack if you\nhave <em>no synchronous middleware</em> loaded into your site. If there is a piece\nof synchronous middleware, then Django must use a thread per request to\nsafely emulate a synchronous environment for it.</p>\n<p class=\"last\">Middleware can be built to support <a class=\"reference internal\" href=\"../http/middleware/#async-middleware\"><span class=\"std std-ref\">both sync and async</span></a> contexts. Some of Django\u2019s middleware is built like\nthis, but not all. To see what middleware Django has to adapt for, you can\nturn on debug logging for the <code class=\"docutils literal notranslate\"><span class=\"pre\">django.request</span></code> logger and look for log\nmessages about <em>\u201cAsynchronous handler adapted for middleware \u2026\u201d</em>.</p>\n</div>\n<p>In both ASGI and WSGI mode, you can still safely use asynchronous support to\nrun code concurrently rather than serially. This is especially handy when\ndealing with external APIs or data stores.</p>\n<p>If you want to call a part of Django that is still synchronous, you will need\nto wrap it in a <a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> call. For example:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">sync_to_async</span>\n\n<span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sync_to_async</span><span class=\"p\">(</span><span class=\"n\">sync_function</span><span class=\"p\">,</span> <span class=\"n\">thread_sensitive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)(</span><span class=\"n\">pk</span><span class=\"o\">=</span><span class=\"mi\">123</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>If you accidentally try to call a part of Django that is synchronous-only\nfrom an async view, you will trigger Django\u2019s\n<a class=\"reference internal\" href=\"#async-safety\"><span class=\"std std-ref\">asynchronous safety protection</span></a> to protect your data from\ncorruption.</p>\n<div class=\"section\" id=\"s-decorators\">\n<span id=\"decorators\"></span><h3>Decorators<a class=\"headerlink\" href=\"#decorators\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"versionadded\">\n<span class=\"title\">New in Django Development version.</span> </div>\n<p>The following decorators can be used with both synchronous and asynchronous\nview functions:</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"../http/decorators/#django.views.decorators.cache.cache_control\" title=\"django.views.decorators.cache.cache_control\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">cache_control()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"../http/decorators/#django.views.decorators.cache.never_cache\" title=\"django.views.decorators.cache.never_cache\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">never_cache()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"../http/decorators/#django.views.decorators.common.no_append_slash\" title=\"django.views.decorators.common.no_append_slash\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">no_append_slash()</span></code></a></li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">xframe_options_deny()</span></code></li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">xframe_options_sameorigin()</span></code></li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">xframe_options_exempt()</span></code></li>\n</ul>\n<p>For example:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.views.decorators.cache</span> <span class=\"kn\">import</span> <span class=\"n\">never_cache</span>\n\n\n<span class=\"nd\">@never_cache</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_sync_view</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n\n<span class=\"nd\">@never_cache</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_async_view</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-queries-the-orm\">\n<span id=\"queries-the-orm\"></span><h3>Queries &amp; the ORM<a class=\"headerlink\" href=\"#queries-the-orm\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>With some exceptions, Django can run ORM queries asynchronously as well:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">author</span> <span class=\"ow\">in</span> <span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">name__startswith</span><span class=\"o\">=</span><span class=\"s2\">&quot;A&quot;</span><span class=\"p\">):</span>\n    <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">author</span><span class=\"o\">.</span><span class=\"n\">books</span><span class=\"o\">.</span><span class=\"n\">afirst</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>Detailed notes can be found in <a class=\"reference internal\" href=\"../db/queries/#async-queries\"><span class=\"std std-ref\">Asynchronous queries</span></a>, but in short:</p>\n<ul class=\"simple\">\n<li>All <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> methods that cause an SQL query to occur have an\n<code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code>-prefixed asynchronous variant.</li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code> is supported on all QuerySets (including the output of\n<code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">values_list()</span></code>.)</li>\n</ul>\n<p>Django also supports some asynchronous model methods that use the database:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_book</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">book</span><span class=\"o\">.</span><span class=\"n\">asave</span><span class=\"p\">(</span><span class=\"n\">using</span><span class=\"o\">=</span><span class=\"s2\">&quot;secondary&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_book_with_tags</span><span class=\"p\">(</span><span class=\"n\">tags</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">acreate</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">book</span><span class=\"o\">.</span><span class=\"n\">tags</span><span class=\"o\">.</span><span class=\"n\">aset</span><span class=\"p\">(</span><span class=\"n\">tags</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Transactions do not yet work in async mode. If you have a piece of code that\nneeds transactions behavior, we recommend you write that piece as a single\nsynchronous function and call it using <a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a>.</p>\n<div class=\"versionchanged\">\n<span class=\"title\">Changed in Django 4.2:</span> <p>Asynchronous model and related manager interfaces were added.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-performance\">\n<span id=\"s-async-performance\"></span><span id=\"performance\"></span><span id=\"async-performance\"></span><h3>Performance<a class=\"headerlink\" href=\"#performance\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>When running in a mode that does not match the view (e.g. an async view under\nWSGI, or a traditional sync view under ASGI), Django must emulate the other\ncall style to allow your code to run. This context-switch causes a small\nperformance penalty of around a millisecond.</p>\n<p>This is also true of middleware. Django will attempt to minimize the number of\ncontext-switches between sync and async. If you have an ASGI server, but all\nyour middleware and views are synchronous, it will switch just once, before it\nenters the middleware stack.</p>\n<p>However, if you put synchronous middleware between an ASGI server and an\nasynchronous view, it will have to switch into sync mode for the middleware and\nthen back to async mode for the view. Django will also hold the sync thread\nopen for middleware exception propagation. This may not be noticeable at first,\nbut adding this penalty of one thread per request can remove any async\nperformance advantage.</p>\n<p>You should do your own performance testing to see what effect ASGI versus WSGI\nhas on your code. In some cases, there may be a performance increase even for\na purely synchronous codebase under ASGI because the request-handling code is\nstill all running asynchronously. In general you will only want to enable ASGI\nmode if you have asynchronous code in your project.</p>\n</div>\n<div class=\"section\" id=\"s-handling-disconnects\">\n<span id=\"s-async-handling-disconnect\"></span><span id=\"handling-disconnects\"></span><span id=\"async-handling-disconnect\"></span><h3>Handling disconnects<a class=\"headerlink\" href=\"#handling-disconnects\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"versionadded\">\n<span class=\"title\">New in Django Development version.</span> </div>\n<p>For long-lived requests, a client may disconnect before the view returns a\nresponse. In this case, an <code class=\"docutils literal notranslate\"><span class=\"pre\">asyncio.CancelledError</span></code> will be raised in the\nview. You can catch this error and handle it if you need to perform any\ncleanup:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_view</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Do some work</span>\n        <span class=\"o\">...</span>\n    <span class=\"k\">except</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">CancelledError</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Handle disconnect</span>\n        <span class=\"k\">raise</span>\n</pre></div>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-async-safety\">\n<span id=\"s-id1\"></span><span id=\"async-safety\"></span><span id=\"id1\"></span><h2>Async safety<a class=\"headerlink\" href=\"#async-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<dl class=\"std envvar\">\n<dt class=\"sig sig-object std\" id=\"envvar-DJANGO_ALLOW_ASYNC_UNSAFE\">\n<code class=\"sig-name descname\"><span class=\"pre\">DJANGO_ALLOW_ASYNC_UNSAFE</span></code><a class=\"headerlink\" href=\"#envvar-DJANGO_ALLOW_ASYNC_UNSAFE\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>Certain key parts of Django are not able to operate safely in an async\nenvironment, as they have global state that is not coroutine-aware. These parts\nof Django are classified as \u201casync-unsafe\u201d, and are protected from execution in\nan async environment. The ORM is the main example, but there are other parts\nthat are also protected in this way.</p>\n<p>If you try to run any of these parts from a thread where there is a <em>running\nevent loop</em>, you will get a\n<a class=\"reference internal\" href=\"../../ref/exceptions/#django.core.exceptions.SynchronousOnlyOperation\" title=\"django.core.exceptions.SynchronousOnlyOperation\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">SynchronousOnlyOperation</span></code></a> error. Note that you\ndon\u2019t have to be inside an async function directly to have this error occur. If\nyou have called a sync function directly from an async function,\nwithout using <a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> or similar, then it can also occur. This is\nbecause your code is still running in a thread with an active event loop, even\nthough it may not be declared as async code.</p>\n<p>If you encounter this error, you should fix your code to not call the offending\ncode from an async context. Instead, write your code that talks to async-unsafe\nfunctions in its own, sync function, and call that using\n<a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">asgiref.sync.sync_to_async()</span></code></a> (or any other way of running sync code in\nits own thread).</p>\n<p>The async context can be imposed upon you by the environment in which you are\nrunning your Django code. For example, <a class=\"reference external\" href=\"https://jupyter.org/\">Jupyter</a> notebooks and <a class=\"reference external\" href=\"https://ipython.org\">IPython</a>\ninteractive shells both transparently provide an active event loop so that it is\neasier to interact with asynchronous APIs.</p>\n<p>If you\u2019re using an IPython shell, you can disable this event loop by running:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>%autoawait off\n</pre></div>\n</div>\n<p>as a command at the IPython prompt. This will allow you to run synchronous code\nwithout generating <a class=\"reference internal\" href=\"../../ref/exceptions/#django.core.exceptions.SynchronousOnlyOperation\" title=\"django.core.exceptions.SynchronousOnlyOperation\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">SynchronousOnlyOperation</span></code></a>\nerrors; however, you also won\u2019t be able to <code class=\"docutils literal notranslate\"><span class=\"pre\">await</span></code> asynchronous APIs. To turn\nthe event loop back on, run:</p>\n<div class=\"highlight-shell notranslate\"><div class=\"highlight\"><pre><span></span>%autoawait on\n</pre></div>\n</div>\n<p>If you\u2019re in an environment other than IPython (or you can\u2019t turn off\n<code class=\"docutils literal notranslate\"><span class=\"pre\">autoawait</span></code> in IPython for some reason), you are <em>certain</em> there is no chance\nof your code being run concurrently, and you <em>absolutely</em> need to run your sync\ncode from an async context, then you can disable the warning by setting the\n<span class=\"target\" id=\"index-0\"></span><a class=\"reference internal\" href=\"#envvar-DJANGO_ALLOW_ASYNC_UNSAFE\"><code class=\"xref std std-envvar docutils literal notranslate\"><span class=\"pre\">DJANGO_ALLOW_ASYNC_UNSAFE</span></code></a> environment variable to any value.</p>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">If you enable this option and there is concurrent access to the\nasync-unsafe parts of Django, you may suffer data loss or corruption. Be\nvery careful and do not use this in production environments.</p>\n</div>\n<p>If you need to do this from within Python, do that with <code class=\"docutils literal notranslate\"><span class=\"pre\">os.environ</span></code>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s2\">&quot;DJANGO_ALLOW_ASYNC_UNSAFE&quot;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;true&quot;</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-async-adapter-functions\">\n<span id=\"async-adapter-functions\"></span><h2>Async adapter functions<a class=\"headerlink\" href=\"#async-adapter-functions\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is necessary to adapt the calling style when calling sync code from an async\ncontext, or vice-versa. For this there are two adapter functions, from the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref.sync</span></code> module: <a class=\"reference internal\" href=\"#asgiref.sync.async_to_sync\" title=\"asgiref.sync.async_to_sync\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a> and <a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a>. They\nare used to transition between the calling styles while preserving\ncompatibility.</p>\n<p>These adapter functions are widely used in Django. The <a class=\"reference external\" href=\"https://pypi.org/project/asgiref/\">asgiref</a> package\nitself is part of the Django project, and it is automatically installed as a\ndependency when you install Django with <code class=\"docutils literal notranslate\"><span class=\"pre\">pip</span></code>.</p>\n<div class=\"section\" id=\"s-async-to-sync\">\n<span id=\"async-to-sync\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code><a class=\"headerlink\" href=\"#async-to-sync\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"asgiref.sync.async_to_sync\">\n<code class=\"sig-name descname\"><span class=\"pre\">async_to_sync</span></code>(<em><span class=\"n\"><span class=\"pre\">async_function</span></span></em>, <em><span class=\"n\"><span class=\"pre\">force_new_loop</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>)<a class=\"headerlink\" href=\"#asgiref.sync.async_to_sync\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>Takes an async function and returns a sync function that wraps it. Can be used\nas either a direct wrapper or a decorator:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">async_to_sync</span>\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">get_data</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n\n\n<span class=\"n\">sync_get_data</span> <span class=\"o\">=</span> <span class=\"n\">async_to_sync</span><span class=\"p\">(</span><span class=\"n\">get_data</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@async_to_sync</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">get_other_data</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>The async function is run in the event loop for the current thread, if one is\npresent. If there is no current event loop, a new event loop is spun up\nspecifically for the single async invocation and shut down again once it\ncompletes. In either situation, the async function will execute on a different\nthread to the calling code.</p>\n<p>Threadlocals and contextvars values are preserved across the boundary in both\ndirections.</p>\n<p><a class=\"reference internal\" href=\"#asgiref.sync.async_to_sync\" title=\"asgiref.sync.async_to_sync\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a> is essentially a more powerful version of the\n<a class=\"reference external\" href=\"https://docs.python.org/3/library/asyncio-runner.html#asyncio.run\" title=\"(in Python v3.11)\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">asyncio.run()</span></code></a> function in Python\u2019s standard library. As well\nas ensuring threadlocals work, it also enables the <code class=\"docutils literal notranslate\"><span class=\"pre\">thread_sensitive</span></code> mode of\n<a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> when that wrapper is used below it.</p>\n</div>\n<div class=\"section\" id=\"s-sync-to-async\">\n<span id=\"sync-to-async\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code><a class=\"headerlink\" href=\"#sync-to-async\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"asgiref.sync.sync_to_async\">\n<code class=\"sig-name descname\"><span class=\"pre\">sync_to_async</span></code>(<em><span class=\"n\"><span class=\"pre\">sync_function</span></span></em>, <em><span class=\"n\"><span class=\"pre\">thread_sensitive</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/asgiref/sync/#sync_to_async\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#asgiref.sync.sync_to_async\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>Takes a sync function and returns an async function that wraps it. Can be used\nas either a direct wrapper or a decorator:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">sync_to_async</span>\n\n<span class=\"n\">async_function</span> <span class=\"o\">=</span> <span class=\"n\">sync_to_async</span><span class=\"p\">(</span><span class=\"n\">sync_function</span><span class=\"p\">,</span> <span class=\"n\">thread_sensitive</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">async_function</span> <span class=\"o\">=</span> <span class=\"n\">sync_to_async</span><span class=\"p\">(</span><span class=\"n\">sensitive_sync_function</span><span class=\"p\">,</span> <span class=\"n\">thread_sensitive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@sync_to_async</span>\n<span class=\"k\">def</span> <span class=\"nf\">sync_function</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>Threadlocals and contextvars values are preserved across the boundary in both\ndirections.</p>\n<p>Sync functions tend to be written assuming they all run in the main\nthread, so <a class=\"reference internal\" href=\"#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> has two threading modes:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">thread_sensitive=True</span></code> (the default): the sync function will run in the\nsame thread as all other <code class=\"docutils literal notranslate\"><span class=\"pre\">thread_sensitive</span></code> functions. This will be the\nmain thread, if the main thread is synchronous and you are using the\n<a class=\"reference internal\" href=\"#asgiref.sync.async_to_sync\" title=\"asgiref.sync.async_to_sync\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a> wrapper.</li>\n<li><code class=\"docutils literal notranslate\"><span class=\"pre\">thread_sensitive=False</span></code>: the sync function will run in a brand new thread\nwhich is then closed once the invocation completes.</li>\n</ul>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\"><code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref</span></code> version 3.3.0 changed the default value of the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">thread_sensitive</span></code> parameter to <code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code>. This is a safer default, and in\nmany cases interacting with Django the correct value, but be sure to\nevaluate uses of <code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code> if updating <code class=\"docutils literal notranslate\"><span class=\"pre\">asgiref</span></code> from a prior\nversion.</p>\n</div>\n<p>Thread-sensitive mode is quite special, and does a lot of work to run all\nfunctions in the same thread. Note, though, that it <em>relies on usage of</em>\n<a class=\"reference internal\" href=\"#asgiref.sync.async_to_sync\" title=\"asgiref.sync.async_to_sync\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a> <em>above it in the stack</em> to correctly run things on the\nmain thread. If you use <code class=\"docutils literal notranslate\"><span class=\"pre\">asyncio.run()</span></code> or similar, it will fall back to\nrunning thread-sensitive functions in a single, shared thread, but this will\nnot be the main thread.</p>\n<p>The reason this is needed in Django is that many libraries, specifically\ndatabase adapters, require that they are accessed in the same thread that they\nwere created in. Also a lot of existing Django code assumes it all runs in the\nsame thread, e.g. middleware adding things to a request for later use in views.</p>\n<p>Rather than introduce potential compatibility issues with this code, we instead\nopted to add this mode so that all existing Django sync code runs in the same\nthread and thus is fully compatible with async mode. Note that sync code will\nalways be in a <em>different</em> thread to any async code that is calling it, so you\nshould avoid passing raw database handles or other thread-sensitive references\naround.</p>\n<p>In practice this restriction means that you should not pass features of the\ndatabase <code class=\"docutils literal notranslate\"><span class=\"pre\">connection</span></code> object when calling <code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code>. Doing so will\ntrigger the thread safety checks:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"go\"># DJANGO_SETTINGS_MODULE=settings.py python -m asyncio</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">asgiref.sync</span> <span class=\"kn\">import</span> <span class=\"n\">sync_to_async</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">connection</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># In an async context so you cannot use the database directly:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"p\">()</span>\n<span class=\"go\">django.core.exceptions.SynchronousOnlyOperation: You cannot call this from</span>\n<span class=\"go\">an async context - use a thread or sync_to_async.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Nor can you pass resolved connection attributes across threads:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">await</span> <span class=\"n\">sync_to_async</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"p\">)()</span>\n<span class=\"go\">django.db.utils.DatabaseError: DatabaseWrapper objects created in a thread</span>\n<span class=\"go\">can only be used in that same thread. The object with alias &#39;default&#39; was</span>\n<span class=\"go\">created in thread id 4371465600 and this is thread id 6131478528.</span>\n</pre></div>\n</div>\n<p>Rather, you should encapsulate all database access within a helper function\nthat can be called with <code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code> without relying on the connection\nobject in the calling code.</p>\n</div>\n<div class=\"section\" id=\"s-use-with-exception-reporting-filters\">\n<span id=\"use-with-exception-reporting-filters\"></span><h3>Use with exception reporting filters<a class=\"headerlink\" href=\"#use-with-exception-reporting-filters\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p>Due to the machinery needed to cross the sync/async boundary,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code> are <strong>not</strong> compatible with\n<a class=\"reference internal\" href=\"../../howto/error-reporting/#django.views.decorators.debug.sensitive_variables\" title=\"django.views.decorators.debug.sensitive_variables\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sensitive_variables()</span></code></a>, used to mask\nlocal variables from exception reports.</p>\n<p class=\"last\">If using these adapters with sensitive variables, ensure to audit exception\nreporting, and consider implementing a <a class=\"reference internal\" href=\"../../howto/error-reporting/#custom-error-reports\"><span class=\"std std-ref\">custom filter</span></a> if necessary.</p>\n</div>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["howto/index", "\u201cHow-to\u201d guides", "N", "next"], ["topics/external-packages", "External packages", "P", "previous"]], "sourcename": "topics/async.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Asynchronous support</a><ul>\n<li><a class=\"reference internal\" href=\"#async-views\">Async views</a><ul>\n<li><a class=\"reference internal\" href=\"#decorators\">Decorators</a></li>\n<li><a class=\"reference internal\" href=\"#queries-the-orm\">Queries &amp; the ORM</a></li>\n<li><a class=\"reference internal\" href=\"#performance\">Performance</a></li>\n<li><a class=\"reference internal\" href=\"#handling-disconnects\">Handling disconnects</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#async-safety\">Async safety</a></li>\n<li><a class=\"reference internal\" href=\"#async-adapter-functions\">Async adapter functions</a><ul>\n<li><a class=\"reference internal\" href=\"#async-to-sync\"><code class=\"docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#sync-to-async\"><code class=\"docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#use-with-exception-reporting-filters\">Use with exception reporting filters</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "topics/async", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}
