{"parents": [{"link": "../../", "title": "Using Django"}, {"link": "../", "title": "Models and databases"}], "prev": {"link": "../queries/", "title": "Making queries"}, "next": {"link": "../search/", "title": "Search"}, "title": "Aggregation", "meta": {}, "body": "<div class=\"section\" id=\"s-aggregation\">\n<span id=\"aggregation\"></span><h1>Aggregation<a class=\"headerlink\" href=\"#aggregation\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>The topic guide on <a class=\"reference internal\" href=\"../queries/\"><span class=\"doc\">Django\u2019s database-abstraction API</span></a>\ndescribed the way that you can use Django queries that create,\nretrieve, update and delete individual objects. However, sometimes you will\nneed to retrieve values that are derived by summarizing or <em>aggregating</em> a\ncollection of objects. This topic guide describes the ways that aggregate values\ncan be generated and returned using Django queries.</p>\n<p>Throughout this guide, we\u2019ll refer to the following models. These models are\nused to track the inventory for a series of online bookstores:</p>\n<div class=\"highlight-python notranslate\" id=\"queryset-model-example\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Author</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">IntegerField</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Publisher</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Book</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">)</span>\n    <span class=\"n\">pages</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">IntegerField</span><span class=\"p\">()</span>\n    <span class=\"n\">price</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DecimalField</span><span class=\"p\">(</span><span class=\"n\">max_digits</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">decimal_places</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">rating</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">FloatField</span><span class=\"p\">()</span>\n    <span class=\"n\">authors</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"n\">Author</span><span class=\"p\">)</span>\n    <span class=\"n\">publisher</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ForeignKey</span><span class=\"p\">(</span><span class=\"n\">Publisher</span><span class=\"p\">,</span> <span class=\"n\">on_delete</span><span class=\"o\">=</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CASCADE</span><span class=\"p\">)</span>\n    <span class=\"n\">pubdate</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateField</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Store</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">)</span>\n    <span class=\"n\">books</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"n\">Book</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"s-cheat-sheet\">\n<span id=\"cheat-sheet\"></span><h2>Cheat sheet<a class=\"headerlink\" href=\"#cheat-sheet\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>In a hurry? Here\u2019s how to do common aggregate queries, assuming the models\nabove:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"go\"># Total number of books.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n<span class=\"go\">2452</span>\n\n<span class=\"go\"># Total number of books with publisher=BaloneyPress</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">publisher__name</span><span class=\"o\">=</span><span class=\"s2\">&quot;BaloneyPress&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n<span class=\"go\">73</span>\n\n<span class=\"go\"># Average price across all books.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;price__avg&#39;: 34.35}</span>\n\n<span class=\"go\"># Max price across all books.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Max</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Max</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;price__max&#39;: Decimal(&#39;81.20&#39;)}</span>\n\n<span class=\"go\"># Difference between the highest priced book and the average price of all books.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">FloatField</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">price_diff</span><span class=\"o\">=</span><span class=\"n\">Max</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">,</span> <span class=\"n\">output_field</span><span class=\"o\">=</span><span class=\"n\">FloatField</span><span class=\"p\">())</span> <span class=\"o\">-</span> <span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"go\">{&#39;price_diff&#39;: 46.85}</span>\n\n<span class=\"go\"># All the following queries involve traversing the Book&lt;-&gt;Publisher</span>\n<span class=\"go\"># foreign key relationship backwards.</span>\n\n<span class=\"go\"># Each publisher, each with a count of books as a &quot;num_books&quot; attribute.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_books</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span>\n<span class=\"go\">&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">73</span>\n\n<span class=\"go\"># Each publisher, with a separate count of books with a rating above and below 5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Q</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">above_5</span> <span class=\"o\">=</span> <span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">,</span> <span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"n\">Q</span><span class=\"p\">(</span><span class=\"n\">book__rating__gt</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">below_5</span> <span class=\"o\">=</span> <span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">,</span> <span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"n\">Q</span><span class=\"p\">(</span><span class=\"n\">book__rating__lte</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">below_5</span><span class=\"o\">=</span><span class=\"n\">below_5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">above_5</span><span class=\"o\">=</span><span class=\"n\">above_5</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">above_5</span>\n<span class=\"go\">23</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">below_5</span>\n<span class=\"go\">12</span>\n\n<span class=\"go\"># The top 5 publishers, in order by number of books.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_books</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">order_by</span><span class=\"p\">(</span><span class=\"s2\">&quot;-num_books&quot;</span><span class=\"p\">)[:</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pubs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">1323</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-generating-aggregates-over-a-queryset\">\n<span id=\"generating-aggregates-over-a-queryset\"></span><h2>Generating aggregates over a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code><a class=\"headerlink\" href=\"#generating-aggregates-over-a-queryset\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Django provides two ways to generate aggregates. The first way is to generate\nsummary values over an entire <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>. For example, say you wanted to\ncalculate the average price of all books available for sale. Django\u2019s query\nsyntax provides a means for describing the set of all books:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>What we need is a way to calculate summary values over the objects that\nbelong to this <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>. This is done by appending an <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code>\nclause onto the <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;price__avg&#39;: 34.35}</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">all()</span></code> is redundant in this example, so this could be simplified to:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;price__avg&#39;: 34.35}</span>\n</pre></div>\n</div>\n<p>The argument to the <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> clause describes the aggregate value that\nwe want to compute - in this case, the average of the <code class=\"docutils literal notranslate\"><span class=\"pre\">price</span></code> field on the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">Book</span></code> model. A list of the aggregate functions that are available can be\nfound in the <a class=\"reference internal\" href=\"../../../ref/models/querysets/#aggregation-functions\"><span class=\"std std-ref\">QuerySet reference</span></a>.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> is a terminal clause for a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> that, when invoked,\nreturns a dictionary of name-value pairs. The name is an identifier for the\naggregate value; the value is the computed aggregate. The name is\nautomatically generated from the name of the field and the aggregate function.\nIf you want to manually specify a name for the aggregate value, you can do so\nby providing that name when you specify the aggregate clause:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">average_price</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;average_price&#39;: 34.35}</span>\n</pre></div>\n</div>\n<p>If you want to generate more than one aggregate, you add another argument to\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> clause. So, if we also wanted to know the maximum and\nminimum price of all books, we would issue the query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span><span class=\"p\">,</span> <span class=\"n\">Max</span><span class=\"p\">,</span> <span class=\"n\">Min</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">),</span> <span class=\"n\">Max</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">),</span> <span class=\"n\">Min</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;price__avg&#39;: 34.35, &#39;price__max&#39;: Decimal(&#39;81.20&#39;), &#39;price__min&#39;: Decimal(&#39;12.99&#39;)}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-generating-aggregates-for-each-item-in-a-queryset\">\n<span id=\"generating-aggregates-for-each-item-in-a-queryset\"></span><h2>Generating aggregates for each item in a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code><a class=\"headerlink\" href=\"#generating-aggregates-for-each-item-in-a-queryset\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The second way to generate summary values is to generate an independent\nsummary for each object in a <a class=\"reference internal\" href=\"../../../ref/models/querysets/#django.db.models.query.QuerySet\" title=\"django.db.models.query.QuerySet\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code></a>. For example, if you are\nretrieving a list of books, you may want to know how many authors contributed\nto each book. Each Book has a many-to-many relationship with the Author; we\nwant to summarize this relationship for each book in the <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>.</p>\n<p>Per-object summaries can be generated using the\n<a class=\"reference internal\" href=\"../../../ref/models/querysets/#django.db.models.query.QuerySet.annotate\" title=\"django.db.models.query.QuerySet.annotate\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">annotate()</span></code></a> clause. When an <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause is\nspecified, each object in the <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> will be annotated with the\nspecified values.</p>\n<p>The syntax for these annotations is identical to that used for the\n<a class=\"reference internal\" href=\"../../../ref/models/querysets/#django.db.models.query.QuerySet.aggregate\" title=\"django.db.models.query.QuerySet.aggregate\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code></a> clause. Each argument to <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> describes\nan aggregate that is to be calculated. For example, to annotate books with the\nnumber of authors:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"go\"># Build an annotated queryset</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span>\n<span class=\"go\"># Interrogate the first object in the queryset</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"go\">&lt;Book: The Definitive Guide to Django&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">authors__count</span>\n<span class=\"go\">2</span>\n<span class=\"go\"># Interrogate the second object in the queryset</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"go\">&lt;Book: Practical Django Projects&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">authors__count</span>\n<span class=\"go\">1</span>\n</pre></div>\n</div>\n<p>As with <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code>, the name for the annotation is automatically derived\nfrom the name of the aggregate function and the name of the field being\naggregated. You can override this default name by providing an alias when you\nspecify the annotation:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_authors</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">num_authors</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">num_authors</span>\n<span class=\"go\">1</span>\n</pre></div>\n</div>\n<p>Unlike <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> is <em>not</em> a terminal clause. The output\nof the <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause is a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>; this <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> can be\nmodified using any other <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> operation, including <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code>,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code>, or even additional calls to <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code>.</p>\n<div class=\"section\" id=\"s-combining-multiple-aggregations\">\n<span id=\"s-id1\"></span><span id=\"combining-multiple-aggregations\"></span><span id=\"id1\"></span><h3>Combining multiple aggregations<a class=\"headerlink\" href=\"#combining-multiple-aggregations\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Combining multiple aggregations with <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> will <a class=\"reference external\" href=\"https://code.djangoproject.com/ticket/10060\">yield the\nwrong results</a> because joins are used instead of subqueries:</p>\n<div class=\"doctest highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">book</span><span class=\"o\">.</span><span class=\"n\">authors</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">book</span><span class=\"o\">.</span><span class=\"n\">store_set</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n<span class=\"go\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s1\">&#39;authors&#39;</span><span class=\"p\">),</span> <span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s1\">&#39;store&#39;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">authors__count</span>\n<span class=\"go\">6</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">store__count</span>\n<span class=\"go\">6</span>\n</pre></div>\n</div>\n<p>For most aggregates, there is no way to avoid this problem, however, the\n<a class=\"reference internal\" href=\"../../../ref/models/querysets/#django.db.models.Count\" title=\"django.db.models.Count\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Count</span></code></a> aggregate has a <code class=\"docutils literal notranslate\"><span class=\"pre\">distinct</span></code> parameter that\nmay help:</p>\n<div class=\"doctest highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s1\">&#39;authors&#39;</span><span class=\"p\">,</span> <span class=\"n\">distinct</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s1\">&#39;store&#39;</span><span class=\"p\">,</span> <span class=\"n\">distinct</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">authors__count</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">q</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">store__count</span>\n<span class=\"go\">3</span>\n</pre></div>\n</div>\n<div class=\"admonition-if-in-doubt-inspect-the-sql-query admonition\">\n<p class=\"first admonition-title\">If in doubt, inspect the SQL query!</p>\n<p class=\"last\">In order to understand what happens in your query, consider inspecting the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">query</span></code> property of your <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>.</p>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-joins-and-aggregates\">\n<span id=\"joins-and-aggregates\"></span><h2>Joins and aggregates<a class=\"headerlink\" href=\"#joins-and-aggregates\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>So far, we have dealt with aggregates over fields that belong to the\nmodel being queried. However, sometimes the value you want to aggregate\nwill belong to a model that is related to the model you are querying.</p>\n<p>When specifying the field to be aggregated in an aggregate function, Django\nwill allow you to use the same <a class=\"reference internal\" href=\"../queries/#field-lookups-intro\"><span class=\"std std-ref\">double underscore notation</span></a> that is used when referring to related fields in\nfilters. Django will then handle any table joins that are required to retrieve\nand aggregate the related value.</p>\n<p>For example, to find the price range of books offered in each store,\nyou could use the annotation:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Max</span><span class=\"p\">,</span> <span class=\"n\">Min</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Store</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">min_price</span><span class=\"o\">=</span><span class=\"n\">Min</span><span class=\"p\">(</span><span class=\"s2\">&quot;books__price&quot;</span><span class=\"p\">),</span> <span class=\"n\">max_price</span><span class=\"o\">=</span><span class=\"n\">Max</span><span class=\"p\">(</span><span class=\"s2\">&quot;books__price&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>This tells Django to retrieve the <code class=\"docutils literal notranslate\"><span class=\"pre\">Store</span></code> model, join (through the\nmany-to-many relationship) with the <code class=\"docutils literal notranslate\"><span class=\"pre\">Book</span></code> model, and aggregate on the\nprice field of the book model to produce a minimum and maximum value.</p>\n<p>The same rules apply to the <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> clause. If you wanted to\nknow the lowest and highest price of any book that is available for sale\nin any of the stores, you could use the aggregate:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Store</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">min_price</span><span class=\"o\">=</span><span class=\"n\">Min</span><span class=\"p\">(</span><span class=\"s2\">&quot;books__price&quot;</span><span class=\"p\">),</span> <span class=\"n\">max_price</span><span class=\"o\">=</span><span class=\"n\">Max</span><span class=\"p\">(</span><span class=\"s2\">&quot;books__price&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>Join chains can be as deep as you require. For example, to extract the\nage of the youngest author of any book available for sale, you could\nissue the query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Store</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">youngest_age</span><span class=\"o\">=</span><span class=\"n\">Min</span><span class=\"p\">(</span><span class=\"s2\">&quot;books__authors__age&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"s-following-relationships-backwards\">\n<span id=\"following-relationships-backwards\"></span><h3>Following relationships backwards<a class=\"headerlink\" href=\"#following-relationships-backwards\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>In a way similar to <a class=\"reference internal\" href=\"../queries/#lookups-that-span-relationships\"><span class=\"std std-ref\">Lookups that span relationships</span></a>, aggregations and\nannotations on fields of models or models that are related to the one you are\nquerying can include traversing \u201creverse\u201d relationships. The lowercase name\nof related models and double-underscores are used here too.</p>\n<p>For example, we can ask for all publishers, annotated with their respective\ntotal book stock counters (note how we use <code class=\"docutils literal notranslate\"><span class=\"pre\">'book'</span></code> to specify the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">Publisher</span></code> -&gt; <code class=\"docutils literal notranslate\"><span class=\"pre\">Book</span></code> reverse foreign key hop):</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span><span class=\"p\">,</span> <span class=\"n\">Count</span><span class=\"p\">,</span> <span class=\"n\">Min</span><span class=\"p\">,</span> <span class=\"n\">Sum</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>(Every <code class=\"docutils literal notranslate\"><span class=\"pre\">Publisher</span></code> in the resulting <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> will have an extra attribute\ncalled <code class=\"docutils literal notranslate\"><span class=\"pre\">book__count</span></code>.)</p>\n<p>We can also ask for the oldest book of any of those managed by every publisher:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">oldest_pubdate</span><span class=\"o\">=</span><span class=\"n\">Min</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__pubdate&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>(The resulting dictionary will have a key called <code class=\"docutils literal notranslate\"><span class=\"pre\">'oldest_pubdate'</span></code>. If no\nsuch alias were specified, it would be the rather long <code class=\"docutils literal notranslate\"><span class=\"pre\">'book__pubdate__min'</span></code>.)</p>\n<p>This doesn\u2019t apply just to foreign keys. It also works with many-to-many\nrelations. For example, we can ask for every author, annotated with the total\nnumber of pages considering all the books the author has (co-)authored (note how we\nuse <code class=\"docutils literal notranslate\"><span class=\"pre\">'book'</span></code> to specify the <code class=\"docutils literal notranslate\"><span class=\"pre\">Author</span></code> -&gt; <code class=\"docutils literal notranslate\"><span class=\"pre\">Book</span></code> reverse many-to-many hop):</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">total_pages</span><span class=\"o\">=</span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__pages&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>(Every <code class=\"docutils literal notranslate\"><span class=\"pre\">Author</span></code> in the resulting <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> will have an extra attribute\ncalled <code class=\"docutils literal notranslate\"><span class=\"pre\">total_pages</span></code>. If no such alias were specified, it would be the rather\nlong <code class=\"docutils literal notranslate\"><span class=\"pre\">book__pages__sum</span></code>.)</p>\n<p>Or ask for the average rating of all the books written by author(s) we have on\nfile:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">average_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__rating&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>(The resulting dictionary will have a key called <code class=\"docutils literal notranslate\"><span class=\"pre\">'average_rating'</span></code>. If no\nsuch alias were specified, it would be the rather long <code class=\"docutils literal notranslate\"><span class=\"pre\">'book__rating__avg'</span></code>.)</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-aggregations-and-other-queryset-clauses\">\n<span id=\"aggregations-and-other-queryset-clauses\"></span><h2>Aggregations and other <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> clauses<a class=\"headerlink\" href=\"#aggregations-and-other-queryset-clauses\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<div class=\"section\" id=\"s-filter-and-exclude\">\n<span id=\"filter-and-exclude\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">exclude()</span></code><a class=\"headerlink\" href=\"#filter-and-exclude\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Aggregates can also participate in filters. Any <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> (or\n<code class=\"docutils literal notranslate\"><span class=\"pre\">exclude()</span></code>) applied to normal model fields will have the effect of\nconstraining the objects that are considered for aggregation.</p>\n<p>When used with an <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause, a filter has the effect of\nconstraining the objects for which an annotation is calculated. For example,\nyou can generate an annotated list of all books that have a title starting\nwith \u201cDjango\u201d using the query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span><span class=\"p\">,</span> <span class=\"n\">Count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">name__startswith</span><span class=\"o\">=</span><span class=\"s2\">&quot;Django&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_authors</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>When used with an <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> clause, a filter has the effect of\nconstraining the objects over which the aggregate is calculated.\nFor example, you can generate the average price of all books with a\ntitle that starts with \u201cDjango\u201d using the query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">name__startswith</span><span class=\"o\">=</span><span class=\"s2\">&quot;Django&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;price&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"s-filtering-on-annotations\">\n<span id=\"s-id2\"></span><span id=\"filtering-on-annotations\"></span><span id=\"id2\"></span><h4>Filtering on annotations<a class=\"headerlink\" href=\"#filtering-on-annotations\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>Annotated values can also be filtered. The alias for the annotation can be\nused in <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">exclude()</span></code> clauses in the same way as any other\nmodel field.</p>\n<p>For example, to generate a list of books that have more than one author,\nyou can issue the query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_authors</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">num_authors__gt</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>This query generates an annotated result set, and then generates a filter\nbased upon that annotation.</p>\n<p>If you need two annotations with two separate filters you can use the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">filter</span></code> argument with any aggregate. For example, to generate a list of\nauthors with a count of highly rated books:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">highly_rated</span> <span class=\"o\">=</span> <span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">,</span> <span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"n\">Q</span><span class=\"p\">(</span><span class=\"n\">book__rating__gte</span><span class=\"o\">=</span><span class=\"mi\">7</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_books</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">),</span> <span class=\"n\">highly_rated_books</span><span class=\"o\">=</span><span class=\"n\">highly_rated</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Each <code class=\"docutils literal notranslate\"><span class=\"pre\">Author</span></code> in the result set will have the <code class=\"docutils literal notranslate\"><span class=\"pre\">num_books</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">highly_rated_books</span></code> attributes. See also <a class=\"reference internal\" href=\"../../../ref/models/conditional-expressions/#conditional-aggregation\"><span class=\"std std-ref\">Conditional aggregation</span></a>.</p>\n<div class=\"admonition-choosing-between-filter-and-queryset-filter admonition\">\n<p class=\"first admonition-title\">Choosing between <code class=\"docutils literal notranslate\"><span class=\"pre\">filter</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet.filter()</span></code></p>\n<p class=\"last\">Avoid using the <code class=\"docutils literal notranslate\"><span class=\"pre\">filter</span></code> argument with a single annotation or\naggregation. It\u2019s more efficient to use <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet.filter()</span></code> to exclude\nrows. The aggregation <code class=\"docutils literal notranslate\"><span class=\"pre\">filter</span></code> argument is only useful when using two or\nmore aggregations over the same relations with different conditionals.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-order-of-annotate-and-filter-clauses\">\n<span id=\"order-of-annotate-and-filter-clauses\"></span><h4>Order of <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> clauses<a class=\"headerlink\" href=\"#order-of-annotate-and-filter-clauses\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>When developing a complex query that involves both <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> clauses, pay particular attention to the order in which the\nclauses are applied to the <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>.</p>\n<p>When an <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause is applied to a query, the annotation is computed\nover the state of the query up to the point where the annotation is requested.\nThe practical implication of this is that <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> are\nnot commutative operations.</p>\n<p>Given:</p>\n<ul class=\"simple\">\n<li>Publisher A has two books with ratings 4 and 5.</li>\n<li>Publisher B has two books with ratings 1 and 4.</li>\n<li>Publisher C has one book with rating 1.</li>\n</ul>\n<p>Here\u2019s an example with the <code class=\"docutils literal notranslate\"><span class=\"pre\">Count</span></code> aggregate:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_books</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">,</span> <span class=\"n\">distinct</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">book__rating__gt</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">(&lt;Publisher: A&gt;, 2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">(&lt;Publisher: B&gt;, 2)</span>\n\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">book__rating__gt</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_books</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;book&quot;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">(&lt;Publisher: A&gt;, 2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">num_books</span>\n<span class=\"go\">(&lt;Publisher: B&gt;, 1)</span>\n</pre></div>\n</div>\n<p>Both queries return a list of publishers that have at least one book with a\nrating exceeding 3.0, hence publisher C is excluded.</p>\n<p>In the first query, the annotation precedes the filter, so the filter has no\neffect on the annotation. <code class=\"docutils literal notranslate\"><span class=\"pre\">distinct=True</span></code> is required to avoid a <a class=\"reference internal\" href=\"#combining-multiple-aggregations\"><span class=\"std std-ref\">query\nbug</span></a>.</p>\n<p>The second query counts the number of books that have a rating exceeding 3.0\nfor each publisher. The filter precedes the annotation, so the filter\nconstrains the objects considered when calculating the annotation.</p>\n<p>Here\u2019s another example with the <code class=\"docutils literal notranslate\"><span class=\"pre\">Avg</span></code> aggregate:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">avg_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__rating&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">book__rating__gt</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">avg_rating</span>\n<span class=\"go\">(&lt;Publisher: A&gt;, 4.5)  # (5+4)/2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">avg_rating</span>\n<span class=\"go\">(&lt;Publisher: B&gt;, 2.5)  # (1+4)/2</span>\n\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Publisher</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">book__rating__gt</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">avg_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__rating&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">avg_rating</span>\n<span class=\"go\">(&lt;Publisher: A&gt;, 4.5)  # (5+4)/2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">avg_rating</span>\n<span class=\"go\">(&lt;Publisher: B&gt;, 4.0)  # 4/1 (book with rating 1 excluded)</span>\n</pre></div>\n</div>\n<p>The first query asks for the average rating of all a publisher\u2019s books for\npublisher\u2019s that have at least one book with a rating exceeding 3.0. The second\nquery asks for the average of a publisher\u2019s book\u2019s ratings for only those\nratings exceeding 3.0.</p>\n<p>It\u2019s difficult to intuit how the ORM will translate complex querysets into SQL\nqueries so when in doubt, inspect the SQL with <code class=\"docutils literal notranslate\"><span class=\"pre\">str(queryset.query)</span></code> and\nwrite plenty of tests.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-order-by\">\n<span id=\"order-by\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code><a class=\"headerlink\" href=\"#order-by\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Annotations can be used as a basis for ordering. When you\ndefine an <code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code> clause, the aggregates you provide can reference\nany alias defined as part of an <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause in the query.</p>\n<p>For example, to order a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> of books by the number of authors\nthat have contributed to the book, you could use the following query:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_authors</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">order_by</span><span class=\"p\">(</span><span class=\"s2\">&quot;num_authors&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"s-values\">\n<span id=\"values\"></span><h3><code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code><a class=\"headerlink\" href=\"#values\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Ordinarily, annotations are generated on a per-object basis - an annotated\n<code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> will return one result for each object in the original\n<code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>. However, when a <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause is used to constrain the\ncolumns that are returned in the result set, the method for evaluating\nannotations is slightly different. Instead of returning an annotated result\nfor each result in the original <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code>, the original results are\ngrouped according to the unique combinations of the fields specified in the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause. An annotation is then provided for each unique group;\nthe annotation is computed over all members of the group.</p>\n<p>For example, consider an author query that attempts to find out the average\nrating of books written by each author:</p>\n<div class=\"doctest highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">average_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s1\">&#39;book__rating&#39;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>This will return one result for each author in the database, annotated with\ntheir average book rating.</p>\n<p>However, the result will be slightly different if you use a <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span><span class=\"s2\">&quot;name&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">average_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__rating&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>In this example, the authors will be grouped by name, so you will only get\nan annotated result for each <em>unique</em> author name. This means if you have\ntwo authors with the same name, their results will be merged into a single\nresult in the output of the query; the average will be computed as the\naverage over the books written by both authors.</p>\n<div class=\"section\" id=\"s-order-of-annotate-and-values-clauses\">\n<span id=\"order-of-annotate-and-values-clauses\"></span><h4>Order of <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clauses<a class=\"headerlink\" href=\"#order-of-annotate-and-values-clauses\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>As with the <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> clause, the order in which <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clauses are applied to a query is significant. If the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause precedes the <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code>, the annotation will be\ncomputed using the grouping described by the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause.</p>\n<p>However, if the <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause precedes the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause,\nthe annotations will be generated over the entire query set. In this case,\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause only constrains the fields that are generated on\noutput.</p>\n<p>For example, if we reverse the order of the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code>\nclause from our previous example:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Author</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">average_rating</span><span class=\"o\">=</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;book__rating&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;average_rating&quot;</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>This will now yield one unique result for each author; however, only\nthe author\u2019s name and the <code class=\"docutils literal notranslate\"><span class=\"pre\">average_rating</span></code> annotation will be returned\nin the output data.</p>\n<p>You should also note that <code class=\"docutils literal notranslate\"><span class=\"pre\">average_rating</span></code> has been explicitly included\nin the list of values to be returned. This is required because of the\nordering of the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause.</p>\n<p>If the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clause precedes the <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause, any annotations\nwill be automatically added to the result set. However, if the <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code>\nclause is applied after the <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause, you need to explicitly\ninclude the aggregate column.</p>\n</div>\n<div class=\"section\" id=\"s-interaction-with-order-by\">\n<span id=\"s-aggregation-ordering-interaction\"></span><span id=\"interaction-with-order-by\"></span><span id=\"aggregation-ordering-interaction\"></span><h4>Interaction with <code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code><a class=\"headerlink\" href=\"#interaction-with-order-by\" title=\"Permalink to this headline\">\u00b6</a></h4>\n<p>Fields that are mentioned in the <code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code> part of a queryset are used\nwhen selecting the output data, even if they are not otherwise specified in the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> call. These extra fields are used to group \u201clike\u201d results together\nand they can make otherwise identical result rows appear to be separate. This\nshows up, particularly, when counting things.</p>\n<p>By way of example, suppose you have a model like this:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Item</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">IntegerField</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>If you want to count how many times each distinct <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> value appears in an\nordered queryset, you might try this:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">items</span> <span class=\"o\">=</span> <span class=\"n\">Item</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">order_by</span><span class=\"p\">(</span><span class=\"s2\">&quot;name&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\"># Warning: not quite correct!</span>\n<span class=\"n\">items</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span><span class=\"s2\">&quot;data&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;id&quot;</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>\u2026which will group the <code class=\"docutils literal notranslate\"><span class=\"pre\">Item</span></code> objects by their common <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code> values and\nthen count the number of <code class=\"docutils literal notranslate\"><span class=\"pre\">id</span></code> values in each group. Except that it won\u2019t\nquite work. The ordering by <code class=\"docutils literal notranslate\"><span class=\"pre\">name</span></code> will also play a part in the grouping, so\nthis query will group by distinct <code class=\"docutils literal notranslate\"><span class=\"pre\">(data,</span> <span class=\"pre\">name)</span></code> pairs, which isn\u2019t what you\nwant. Instead, you should construct this queryset:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">items</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span><span class=\"s2\">&quot;data&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;id&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">order_by</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>\u2026clearing any ordering in the query. You could also order by, say, <code class=\"docutils literal notranslate\"><span class=\"pre\">data</span></code>\nwithout any harmful effects, since that is already playing a role in the\nquery.</p>\n<p>This behavior is the same as that noted in the queryset documentation for\n<a class=\"reference internal\" href=\"../../../ref/models/querysets/#django.db.models.query.QuerySet.distinct\" title=\"django.db.models.query.QuerySet.distinct\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">distinct()</span></code></a> and the general rule is the\nsame: normally you won\u2019t want extra columns playing a part in the result, so\nclear out the ordering, or at least make sure it\u2019s restricted only to those\nfields you also select in a <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> call.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">You might reasonably ask why Django doesn\u2019t remove the extraneous columns\nfor you. The main reason is consistency with <code class=\"docutils literal notranslate\"><span class=\"pre\">distinct()</span></code> and other\nplaces: Django <strong>never</strong> removes ordering constraints that you have\nspecified (and we can\u2019t change those other methods\u2019 behavior, as that\nwould violate our <a class=\"reference internal\" href=\"../../../misc/api-stability/\"><span class=\"doc\">API stability</span></a> policy).</p>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-aggregating-annotations\">\n<span id=\"aggregating-annotations\"></span><h3>Aggregating annotations<a class=\"headerlink\" href=\"#aggregating-annotations\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>You can also generate an aggregate on the result of an annotation. When you\ndefine an <code class=\"docutils literal notranslate\"><span class=\"pre\">aggregate()</span></code> clause, the aggregates you provide can reference\nany alias defined as part of an <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> clause in the query.</p>\n<p>For example, if you wanted to calculate the average number of authors per\nbook you first annotate the set of books with the author count, then\naggregate that author count, referencing the annotation field:</p>\n<div class=\"highlight-pycon notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models</span> <span class=\"kn\">import</span> <span class=\"n\">Avg</span><span class=\"p\">,</span> <span class=\"n\">Count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Book</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">num_authors</span><span class=\"o\">=</span><span class=\"n\">Count</span><span class=\"p\">(</span><span class=\"s2\">&quot;authors&quot;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">aggregate</span><span class=\"p\">(</span><span class=\"n\">Avg</span><span class=\"p\">(</span><span class=\"s2\">&quot;num_authors&quot;</span><span class=\"p\">))</span>\n<span class=\"go\">{&#39;num_authors__avg&#39;: 1.66}</span>\n</pre></div>\n</div>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["topics/db/search", "Search", "N", "next"], ["topics/db/queries", "Making queries", "P", "previous"]], "sourcename": "topics/db/aggregation.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Aggregation</a><ul>\n<li><a class=\"reference internal\" href=\"#cheat-sheet\">Cheat sheet</a></li>\n<li><a class=\"reference internal\" href=\"#generating-aggregates-over-a-queryset\">Generating aggregates over a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#generating-aggregates-for-each-item-in-a-queryset\">Generating aggregates for each item in a <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#combining-multiple-aggregations\">Combining multiple aggregations</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#joins-and-aggregates\">Joins and aggregates</a><ul>\n<li><a class=\"reference internal\" href=\"#following-relationships-backwards\">Following relationships backwards</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#aggregations-and-other-queryset-clauses\">Aggregations and other <code class=\"docutils literal notranslate\"><span class=\"pre\">QuerySet</span></code> clauses</a><ul>\n<li><a class=\"reference internal\" href=\"#filter-and-exclude\"><code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">exclude()</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#filtering-on-annotations\">Filtering on annotations</a></li>\n<li><a class=\"reference internal\" href=\"#order-of-annotate-and-filter-clauses\">Order of <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">filter()</span></code> clauses</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#order-by\"><code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#values\"><code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#order-of-annotate-and-values-clauses\">Order of <code class=\"docutils literal notranslate\"><span class=\"pre\">annotate()</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">values()</span></code> clauses</a></li>\n<li><a class=\"reference internal\" href=\"#interaction-with-order-by\">Interaction with <code class=\"docutils literal notranslate\"><span class=\"pre\">order_by()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#aggregating-annotations\">Aggregating annotations</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "topics/db/aggregation", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}