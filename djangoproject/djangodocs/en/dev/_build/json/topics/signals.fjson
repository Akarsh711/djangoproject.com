{"parents": [{"link": "../", "title": "Using Django"}], "prev": {"link": "../settings/", "title": "Django settings"}, "next": {"link": "../checks/", "title": "System check framework"}, "title": "Signals", "meta": {}, "body": "<div class=\"section\" id=\"s-module-django.dispatch\">\n<span id=\"s-signals\"></span><span id=\"module-django.dispatch\"></span><span id=\"signals\"></span><h1>Signals<a class=\"headerlink\" href=\"#module-django.dispatch\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Django includes a \u201csignal dispatcher\u201d which helps decoupled applications get\nnotified when actions occur elsewhere in the framework. In a nutshell, signals\nallow certain <em>senders</em> to notify a set of <em>receivers</em> that some action has\ntaken place. They\u2019re especially useful when many pieces of code may be\ninterested in the same events.</p>\n<p>For example, a third-party app can register to be notified of settings\nchanges:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.apps</span> <span class=\"kn\">import</span> <span class=\"n\">AppConfig</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.core.signals</span> <span class=\"kn\">import</span> <span class=\"n\">setting_changed</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">my_callback</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Setting changed!&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyAppConfig</span><span class=\"p\">(</span><span class=\"n\">AppConfig</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">ready</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">setting_changed</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">my_callback</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Django\u2019s <a class=\"reference internal\" href=\"../../ref/signals/\"><span class=\"doc\">built-in signals</span></a> let user code get notified of\ncertain actions.</p>\n<p>You can also define and send your own custom signals. See\n<a class=\"reference internal\" href=\"#defining-and-sending-signals\"><span class=\"std std-ref\">Defining and sending signals</span></a> below.</p>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p>Signals give the appearance of loose coupling, but they can quickly lead to\ncode that is hard to understand, adjust and debug.</p>\n<p class=\"last\">Where possible you should opt for directly calling the handling code,\nrather than dispatching via a signal.</p>\n</div>\n<div class=\"section\" id=\"s-listening-to-signals\">\n<span id=\"listening-to-signals\"></span><h2>Listening to signals<a class=\"headerlink\" href=\"#listening-to-signals\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>To receive a signal, register a <em>receiver</em> function using the\n<a class=\"reference internal\" href=\"#django.dispatch.Signal.connect\" title=\"django.dispatch.Signal.connect\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.connect()</span></code></a> method. The receiver function is called when the signal\nis sent. All of the signal\u2019s receiver functions are called one at a time, in\nthe order they were registered.</p>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.connect\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">connect</span></code>(<em><span class=\"n\"><span class=\"pre\">receiver</span></span></em>, <em><span class=\"n\"><span class=\"pre\">sender</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em><span class=\"n\"><span class=\"pre\">weak</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>, <em><span class=\"n\"><span class=\"pre\">dispatch_uid</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.connect\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.connect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><ul class=\"first last simple\">\n<li><strong>receiver</strong> \u2013 The callback function which will be connected to this\nsignal. See <a class=\"reference internal\" href=\"#receiver-functions\"><span class=\"std std-ref\">Receiver functions</span></a> for more information.</li>\n<li><strong>sender</strong> \u2013 Specifies a particular sender to receive signals from. See\n<a class=\"reference internal\" href=\"#connecting-to-specific-signals\"><span class=\"std std-ref\">Connecting to signals sent by specific senders</span></a> for more information.</li>\n<li><strong>weak</strong> \u2013 Django stores signal handlers as weak references by\ndefault. Thus, if your receiver is a local function, it may be\ngarbage collected. To prevent this, pass <code class=\"docutils literal notranslate\"><span class=\"pre\">weak=False</span></code> when you call\nthe signal\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">connect()</span></code> method.</li>\n<li><strong>dispatch_uid</strong> \u2013 A unique identifier for a signal receiver in cases\nwhere duplicate signals may be sent. See\n<a class=\"reference internal\" href=\"#preventing-duplicate-signals\"><span class=\"std std-ref\">Preventing duplicate signals</span></a> for more information.</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</dd></dl>\n\n<p>Let\u2019s see how this works by registering a signal that\ngets called after each HTTP request is finished. We\u2019ll be connecting to the\n<a class=\"reference internal\" href=\"../../ref/signals/#django.core.signals.request_finished\" title=\"django.core.signals.request_finished\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">request_finished</span></code></a> signal.</p>\n<div class=\"section\" id=\"s-receiver-functions\">\n<span id=\"s-id1\"></span><span id=\"receiver-functions\"></span><span id=\"id1\"></span><h3>Receiver functions<a class=\"headerlink\" href=\"#receiver-functions\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>First, we need to define a receiver function. A receiver can be any Python\nfunction or method:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">my_callback</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Request finished!&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Notice that the function takes a <code class=\"docutils literal notranslate\"><span class=\"pre\">sender</span></code> argument, along with wildcard\nkeyword arguments (<code class=\"docutils literal notranslate\"><span class=\"pre\">**kwargs</span></code>); all signal handlers must take these arguments.</p>\n<p>We\u2019ll look at senders <a class=\"reference internal\" href=\"#connecting-to-specific-signals\"><span class=\"std std-ref\">a bit later</span></a>, but\nright now look at the <code class=\"docutils literal notranslate\"><span class=\"pre\">**kwargs</span></code> argument. All signals send keyword\narguments, and may change those keyword arguments at any time. In the case of\n<a class=\"reference internal\" href=\"../../ref/signals/#django.core.signals.request_finished\" title=\"django.core.signals.request_finished\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">request_finished</span></code></a>, it\u2019s documented as sending no\narguments, which means we might be tempted to write our signal handling as\n<code class=\"docutils literal notranslate\"><span class=\"pre\">my_callback(sender)</span></code>.</p>\n<p>This would be wrong \u2013 in fact, Django will throw an error if you do so. That\u2019s\nbecause at any point arguments could get added to the signal and your receiver\nmust be able to handle those new arguments.</p>\n<p>Receivers may also be asynchronous functions, with the same signature but\ndeclared using <code class=\"docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_callback</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Request finished!&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Signals can be sent either synchronously or asynchronously, and receivers will\nautomatically be adapted to the correct call-style. See <a class=\"reference internal\" href=\"#sending-signals\"><span class=\"std std-ref\">sending signals</span></a> for more information.</p>\n<div class=\"versionchanged\">\n<span class=\"title\">Changed in Django Development version:</span> <p>Support for asynchronous receivers was added.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-connecting-receiver-functions\">\n<span id=\"s-id2\"></span><span id=\"connecting-receiver-functions\"></span><span id=\"id2\"></span><h3>Connecting receiver functions<a class=\"headerlink\" href=\"#connecting-receiver-functions\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>There are two ways you can connect a receiver to a signal. You can take the\nmanual connect route:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.core.signals</span> <span class=\"kn\">import</span> <span class=\"n\">request_finished</span>\n\n<span class=\"n\">request_finished</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">my_callback</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Alternatively, you can use a <a class=\"reference internal\" href=\"#django.dispatch.receiver\" title=\"django.dispatch.receiver\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">receiver()</span></code></a> decorator:</p>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.receiver\">\n<code class=\"sig-name descname\"><span class=\"pre\">receiver</span></code>(<em><span class=\"n\"><span class=\"pre\">signal</span></span></em>, <em><span class=\"o\"><span class=\"pre\">**</span></span><span class=\"n\"><span class=\"pre\">kwargs</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#receiver\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.receiver\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><table class=\"docutils field-list\" frame=\"void\" rules=\"none\">\n<col class=\"field-name\" />\n<col class=\"field-body\" />\n<tbody valign=\"top\">\n<tr class=\"field-odd field\"><th class=\"field-name\">Parameters:</th><td class=\"field-body\"><ul class=\"first last simple\">\n<li><strong>signal</strong> \u2013 A signal or a list of signals to connect a function to.</li>\n<li><strong>kwargs</strong> \u2013 Wildcard keyword arguments to pass to a\n<a class=\"reference internal\" href=\"#receiver-functions\"><span class=\"std std-ref\">function</span></a>.</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</dd></dl>\n\n<p>Here\u2019s how you connect with the decorator:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.core.signals</span> <span class=\"kn\">import</span> <span class=\"n\">request_finished</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.dispatch</span> <span class=\"kn\">import</span> <span class=\"n\">receiver</span>\n\n\n<span class=\"nd\">@receiver</span><span class=\"p\">(</span><span class=\"n\">request_finished</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_callback</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Request finished!&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Now, our <code class=\"docutils literal notranslate\"><span class=\"pre\">my_callback</span></code> function will be called each time a request finishes.</p>\n<div class=\"admonition-where-should-this-code-live admonition\">\n<p class=\"first admonition-title\">Where should this code live?</p>\n<p>Strictly speaking, signal handling and registration code can live anywhere\nyou like, although it\u2019s recommended to avoid the application\u2019s root module\nand its <code class=\"docutils literal notranslate\"><span class=\"pre\">models</span></code> module to minimize side-effects of importing code.</p>\n<p>In practice, signal handlers are usually defined in a <code class=\"docutils literal notranslate\"><span class=\"pre\">signals</span></code>\nsubmodule of the application they relate to. Signal receivers are\nconnected in the <a class=\"reference internal\" href=\"../../ref/applications/#django.apps.AppConfig.ready\" title=\"django.apps.AppConfig.ready\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">ready()</span></code></a> method of your\napplication <a class=\"reference internal\" href=\"../../ref/applications/#configuring-applications-ref\"><span class=\"std std-ref\">configuration class</span></a>. If\nyou\u2019re using the <a class=\"reference internal\" href=\"#django.dispatch.receiver\" title=\"django.dispatch.receiver\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">receiver()</span></code></a> decorator, import the <code class=\"docutils literal notranslate\"><span class=\"pre\">signals</span></code>\nsubmodule inside <a class=\"reference internal\" href=\"../../ref/applications/#django.apps.AppConfig.ready\" title=\"django.apps.AppConfig.ready\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">ready()</span></code></a>, this will implicitly\nconnect signal handlers:</p>\n<div class=\"last highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.apps</span> <span class=\"kn\">import</span> <span class=\"n\">AppConfig</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.core.signals</span> <span class=\"kn\">import</span> <span class=\"n\">request_finished</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyAppConfig</span><span class=\"p\">(</span><span class=\"n\">AppConfig</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">ready</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Implicitly connect signal handlers decorated with @receiver.</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">.</span> <span class=\"kn\">import</span> <span class=\"n\">signals</span>\n\n        <span class=\"c1\"># Explicitly connect a signal handler.</span>\n        <span class=\"n\">request_finished</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">signals</span><span class=\"o\">.</span><span class=\"n\">my_callback</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <a class=\"reference internal\" href=\"../../ref/applications/#django.apps.AppConfig.ready\" title=\"django.apps.AppConfig.ready\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">ready()</span></code></a> method may be executed more than\nonce during testing, so you may want to <a class=\"reference internal\" href=\"#preventing-duplicate-signals\"><span class=\"std std-ref\">guard your signals from\nduplication</span></a>, especially if you\u2019re planning\nto send them within tests.</p>\n</div>\n</div>\n<div class=\"section\" id=\"s-connecting-to-signals-sent-by-specific-senders\">\n<span id=\"s-connecting-to-specific-signals\"></span><span id=\"connecting-to-signals-sent-by-specific-senders\"></span><span id=\"connecting-to-specific-signals\"></span><h3>Connecting to signals sent by specific senders<a class=\"headerlink\" href=\"#connecting-to-signals-sent-by-specific-senders\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Some signals get sent many times, but you\u2019ll only be interested in receiving a\ncertain subset of those signals. For example, consider the\n<a class=\"reference internal\" href=\"../../ref/signals/#django.db.models.signals.pre_save\" title=\"django.db.models.signals.pre_save\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">django.db.models.signals.pre_save</span></code></a> signal sent before a model gets saved.\nMost of the time, you don\u2019t need to know when <em>any</em> model gets saved \u2013 just\nwhen one <em>specific</em> model is saved.</p>\n<p>In these cases, you can register to receive signals sent only by particular\nsenders. In the case of <a class=\"reference internal\" href=\"../../ref/signals/#django.db.models.signals.pre_save\" title=\"django.db.models.signals.pre_save\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">django.db.models.signals.pre_save</span></code></a>, the sender\nwill be the model class being saved, so you can indicate that you only want\nsignals sent by some model:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.db.models.signals</span> <span class=\"kn\">import</span> <span class=\"n\">pre_save</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.dispatch</span> <span class=\"kn\">import</span> <span class=\"n\">receiver</span>\n<span class=\"kn\">from</span> <span class=\"nn\">myapp.models</span> <span class=\"kn\">import</span> <span class=\"n\">MyModel</span>\n\n\n<span class=\"nd\">@receiver</span><span class=\"p\">(</span><span class=\"n\">pre_save</span><span class=\"p\">,</span> <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"n\">MyModel</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_handler</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">my_handler</span></code> function will only be called when an instance of <code class=\"docutils literal notranslate\"><span class=\"pre\">MyModel</span></code>\nis saved.</p>\n<p>Different signals use different objects as their senders; you\u2019ll need to consult\nthe <a class=\"reference internal\" href=\"../../ref/signals/\"><span class=\"doc\">built-in signal documentation</span></a> for details of each\nparticular signal.</p>\n</div>\n<div class=\"section\" id=\"s-preventing-duplicate-signals\">\n<span id=\"s-id3\"></span><span id=\"preventing-duplicate-signals\"></span><span id=\"id3\"></span><h3>Preventing duplicate signals<a class=\"headerlink\" href=\"#preventing-duplicate-signals\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>In some circumstances, the code connecting receivers to signals may run\nmultiple times. This can cause your receiver function to be registered more\nthan once, and thus called as many times for a signal event. For example, the\n<a class=\"reference internal\" href=\"../../ref/applications/#django.apps.AppConfig.ready\" title=\"django.apps.AppConfig.ready\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">ready()</span></code></a> method may be executed more than once\nduring testing. More generally, this occurs everywhere your project imports the\nmodule where you define the signals, because signal registration runs as many\ntimes as it is imported.</p>\n<p>If this behavior is problematic (such as when using signals to\nsend an email whenever a model is saved), pass a unique identifier as\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">dispatch_uid</span></code> argument to identify your receiver function. This\nidentifier will usually be a string, although any hashable object will\nsuffice. The end result is that your receiver function will only be\nbound to the signal once for each unique <code class=\"docutils literal notranslate\"><span class=\"pre\">dispatch_uid</span></code> value:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">django.core.signals</span> <span class=\"kn\">import</span> <span class=\"n\">request_finished</span>\n\n<span class=\"n\">request_finished</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">my_callback</span><span class=\"p\">,</span> <span class=\"n\">dispatch_uid</span><span class=\"o\">=</span><span class=\"s2\">&quot;my_unique_identifier&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-defining-and-sending-signals\">\n<span id=\"s-id4\"></span><span id=\"defining-and-sending-signals\"></span><span id=\"id4\"></span><h2>Defining and sending signals<a class=\"headerlink\" href=\"#defining-and-sending-signals\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Your applications can take advantage of the signal infrastructure and provide\nits own signals.</p>\n<div class=\"admonition-when-to-use-custom-signals admonition\">\n<p class=\"first admonition-title\">When to use custom signals</p>\n<p class=\"last\">Signals are implicit function calls which make debugging harder. If the\nsender and receiver of your custom signal are both within your project,\nyou\u2019re better off using an explicit function call.</p>\n</div>\n<div class=\"section\" id=\"s-defining-signals\">\n<span id=\"defining-signals\"></span><h3>Defining signals<a class=\"headerlink\" href=\"#defining-signals\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"py class\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal\">\n<em class=\"property\"><span class=\"pre\">class</span><span class=\"w\"> </span></em><code class=\"sig-name descname\"><span class=\"pre\">Signal</span></code><a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>All signals are <a class=\"reference internal\" href=\"#django.dispatch.Signal\" title=\"django.dispatch.Signal\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">django.dispatch.Signal</span></code></a> instances.</p>\n<p>For example:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">django.dispatch</span>\n\n<span class=\"n\">pizza_done</span> <span class=\"o\">=</span> <span class=\"n\">django</span><span class=\"o\">.</span><span class=\"n\">dispatch</span><span class=\"o\">.</span><span class=\"n\">Signal</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>This declares a <code class=\"docutils literal notranslate\"><span class=\"pre\">pizza_done</span></code> signal.</p>\n</div>\n<div class=\"section\" id=\"s-sending-signals\">\n<span id=\"s-id5\"></span><span id=\"sending-signals\"></span><span id=\"id5\"></span><h3>Sending signals<a class=\"headerlink\" href=\"#sending-signals\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>There are two ways to send signals synchronously in Django.</p>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.send\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">send</span></code>(<em><span class=\"n\"><span class=\"pre\">sender</span></span></em>, <em><span class=\"o\"><span class=\"pre\">**</span></span><span class=\"n\"><span class=\"pre\">kwargs</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.send\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.send\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.send_robust\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">send_robust</span></code>(<em><span class=\"n\"><span class=\"pre\">sender</span></span></em>, <em><span class=\"o\"><span class=\"pre\">**</span></span><span class=\"n\"><span class=\"pre\">kwargs</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.send_robust\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.send_robust\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>Signals may also be sent asynchronously.</p>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.asend\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">asend</span></code>(<em><span class=\"n\"><span class=\"pre\">sender</span></span></em>, <em><span class=\"o\"><span class=\"pre\">**</span></span><span class=\"n\"><span class=\"pre\">kwargs</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.asend\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.asend\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.asend_robust\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">asend_robust</span></code>(<em><span class=\"n\"><span class=\"pre\">sender</span></span></em>, <em><span class=\"o\"><span class=\"pre\">**</span></span><span class=\"n\"><span class=\"pre\">kwargs</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.asend_robust\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.asend_robust\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>To send a signal, call either <a class=\"reference internal\" href=\"#django.dispatch.Signal.send\" title=\"django.dispatch.Signal.send\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.send()</span></code></a>, <a class=\"reference internal\" href=\"#django.dispatch.Signal.send_robust\" title=\"django.dispatch.Signal.send_robust\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.send_robust()</span></code></a>,\n<a class=\"reference internal\" href=\"#django.dispatch.Signal.asend\" title=\"django.dispatch.Signal.asend\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">await</span> <span class=\"pre\">Signal.asend()</span></code></a>, or\n<a class=\"reference internal\" href=\"#django.dispatch.Signal.asend_robust\" title=\"django.dispatch.Signal.asend_robust\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">await</span> <span class=\"pre\">Signal.asend_robust()</span></code></a>. You must provide the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sender</span></code> argument (which is a class most of the time) and may provide as many\nother keyword arguments as you like.</p>\n<p>For example, here\u2019s how sending our <code class=\"docutils literal notranslate\"><span class=\"pre\">pizza_done</span></code> signal might look:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">PizzaStore</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">send_pizza</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">toppings</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">):</span>\n        <span class=\"n\">pizza_done</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"p\">,</span> <span class=\"n\">toppings</span><span class=\"o\">=</span><span class=\"n\">toppings</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"n\">size</span><span class=\"p\">)</span>\n        <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>All four methods return a list of tuple pairs <code class=\"docutils literal notranslate\"><span class=\"pre\">[(receiver,</span> <span class=\"pre\">response),</span> <span class=\"pre\">...]</span></code>,\nrepresenting the list of called receiver functions and their response values.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">send()</span></code> differs from <code class=\"docutils literal notranslate\"><span class=\"pre\">send_robust()</span></code> in how exceptions raised by receiver\nfunctions are handled. <code class=\"docutils literal notranslate\"><span class=\"pre\">send()</span></code> does <em>not</em> catch any exceptions raised by\nreceivers; it simply allows errors to propagate. Thus not all receivers may\nbe notified of a signal in the face of an error.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">send_robust()</span></code> catches all errors derived from Python\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">Exception</span></code> class,\nand ensures all receivers are notified of the signal. If an error occurs, the\nerror instance is returned in the tuple pair for the receiver that raised the error.</p>\n<p>The tracebacks are present on the <code class=\"docutils literal notranslate\"><span class=\"pre\">__traceback__</span></code> attribute of the errors\nreturned when calling <code class=\"docutils literal notranslate\"><span class=\"pre\">send_robust()</span></code>.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">asend()</span></code> is similar as <code class=\"docutils literal notranslate\"><span class=\"pre\">send()</span></code>, but it is coroutine that must be\nawaited:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">asend_pizza</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">toppings</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">pizza_done</span><span class=\"o\">.</span><span class=\"n\">asend</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"p\">,</span> <span class=\"n\">toppings</span><span class=\"o\">=</span><span class=\"n\">toppings</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"n\">size</span><span class=\"p\">)</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>Whether synchronous or asynchronous, receivers will be correctly adapted to\nwhether <code class=\"docutils literal notranslate\"><span class=\"pre\">send()</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">asend()</span></code> is used. Synchronous receivers will be\ncalled using <a class=\"reference internal\" href=\"../async/#asgiref.sync.sync_to_async\" title=\"asgiref.sync.sync_to_async\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sync_to_async()</span></code></a> when invoked via <code class=\"docutils literal notranslate\"><span class=\"pre\">asend()</span></code>. Asynchronous\nreceivers will be called using <a class=\"reference internal\" href=\"../async/#asgiref.sync.async_to_sync\" title=\"asgiref.sync.async_to_sync\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">async_to_sync()</span></code></a> when invoked via\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sync()</span></code>. Similar to the <a class=\"reference internal\" href=\"../async/#async-performance\"><span class=\"std std-ref\">case for middleware</span></a>,\nthere is a small performance cost to adapting receivers in this way. Note that\nin order to reduce the number of sync/async calling-style switches within a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">send()</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">asend()</span></code> call, the receivers are grouped by whether or not\nthey are async before being called. This means that an asynchronous receiver\nregistered before a synchronous receiver may be executed after the synchronous\nreceiver. In addition, async receivers are executed concurrently using\n<code class=\"docutils literal notranslate\"><span class=\"pre\">asyncio.gather()</span></code>.</p>\n<p>All built-in signals, except those in the async request-response cycle, are\ndispatched using <a class=\"reference internal\" href=\"#django.dispatch.Signal.send\" title=\"django.dispatch.Signal.send\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.send()</span></code></a>.</p>\n<div class=\"versionchanged\">\n<span class=\"title\">Changed in Django Development version:</span> <p>Support for asynchronous signals was added.</p>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"s-disconnecting-signals\">\n<span id=\"disconnecting-signals\"></span><h2>Disconnecting signals<a class=\"headerlink\" href=\"#disconnecting-signals\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<dl class=\"py method\">\n<dt class=\"sig sig-object py\" id=\"django.dispatch.Signal.disconnect\">\n<code class=\"sig-prename descclassname\"><span class=\"pre\">Signal.</span></code><code class=\"sig-name descname\"><span class=\"pre\">disconnect</span></code>(<em><span class=\"n\"><span class=\"pre\">receiver</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em><span class=\"n\"><span class=\"pre\">sender</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em><span class=\"n\"><span class=\"pre\">dispatch_uid</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>)<a class=\"reference internal\" href=\"../../_modules/django/dispatch/dispatcher/#Signal.disconnect\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a><a class=\"headerlink\" href=\"#django.dispatch.Signal.disconnect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<p>To disconnect a receiver from a signal, call <a class=\"reference internal\" href=\"#django.dispatch.Signal.disconnect\" title=\"django.dispatch.Signal.disconnect\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.disconnect()</span></code></a>. The\narguments are as described in <a class=\"reference internal\" href=\"#django.dispatch.Signal.connect\" title=\"django.dispatch.Signal.connect\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">Signal.connect()</span></code></a>. The method returns\n<code class=\"docutils literal notranslate\"><span class=\"pre\">True</span></code> if a receiver was disconnected and <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code> if not. When <code class=\"docutils literal notranslate\"><span class=\"pre\">sender</span></code>\nis passed as a lazy reference to <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;app</span> <span class=\"pre\">label&gt;.&lt;model&gt;</span></code>, this method always\nreturns <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>.</p>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">receiver</span></code> argument indicates the registered receiver to disconnect. It\nmay be <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">dispatch_uid</span></code> is used to identify the receiver.</p>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["topics/checks", "System check framework", "N", "next"], ["topics/settings", "Django settings", "P", "previous"]], "sourcename": "topics/signals.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Signals</a><ul>\n<li><a class=\"reference internal\" href=\"#listening-to-signals\">Listening to signals</a><ul>\n<li><a class=\"reference internal\" href=\"#receiver-functions\">Receiver functions</a></li>\n<li><a class=\"reference internal\" href=\"#connecting-receiver-functions\">Connecting receiver functions</a></li>\n<li><a class=\"reference internal\" href=\"#connecting-to-signals-sent-by-specific-senders\">Connecting to signals sent by specific senders</a></li>\n<li><a class=\"reference internal\" href=\"#preventing-duplicate-signals\">Preventing duplicate signals</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#defining-and-sending-signals\">Defining and sending signals</a><ul>\n<li><a class=\"reference internal\" href=\"#defining-signals\">Defining signals</a></li>\n<li><a class=\"reference internal\" href=\"#sending-signals\">Sending signals</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#disconnecting-signals\">Disconnecting signals</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".txt", "current_page_name": "topics/signals", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "include_console_assets": false}
